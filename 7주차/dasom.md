# 7장 리액트 동시성

2025.03.29 dasom

## 7.1 동기식 렌더링의 문제

동기식 렌더링은 메인 스레드를 가로막아 사용자 경험이 저하된다는 문제가 있다.
이를 해결하기 위해 여러 업데이트를 일괄로 처리하는 방법도 있지만 역시 한계가 존재한다.
동기식 렌더링과 일괄 처리 모두 우선순위가 존재하지 않기 때문이다.

리액트는 동시성 렌더링을 사용해 업데이트 작업의 중요도와 긴급도에 따라 우선순위를 정하고, 우선순위가 높은 작업이 블락당하지 않도록 한다.
또한 이 덕분에 리액트는 타임 슬라이싱(렌더링 프로세스를 작은 덩어리로 분할해 점진적으로 처리하는 기법)도 가능하다.


## 7.2 파이버 다시 보기

리액트는 파이버 재조정자를 통해 동시성 렌더링을 가능하게 한다.

> [!NOTE]
> 파이버: 각 컴포넌트에 대한 정보를 담고 있는 JavaScript 객체이며, 컴포넌트 트리 전체를 연결하는 트리 구조를 이룬다


## 7.3 업데이트 예약과 지연

파이버 재조정자는 스케줄러와 여러 API에 의존해 업데이트 예약과 지연 기능을 구현한다.

> [!NOTE]
> 스케줄러: setTimeout, MessageChannel 등의 브라우저 API를 사용해 작업의 실행 시점을 예약 및 관리하는 시스템

예를 들어, 채팅창이라는 서비스가 있을 때
크게 **메세지를 보내기 위한 입력 이벤트**와 **받은 메세지를 렌더링 하는 이벤트** 두 가지의 이벤트가 존재하는데,

서버에서 새 메세지를 수신해 렌더링해야할 때, 리액트는 **렌더 레인**을 통해 이 내용을 **동기적**으로 렌더링하고, 따라서 입력 이벤트에 지연이 발생할 수 있다.

새 메세지를 렌더링하는 작업의 우선순위를 낮추기 위해서는 관련 상태 업데이트를 useTransition 훅의 startTransition 함수로 감쌀 수 있다.


## 7.4 더 깊이 들어가기

### 7.4.1 스케줄러
스케줄러는 타이밍 관련 유틸리티를 제공하는 독립형 패키지로, 파이버 재조정자와는 별개로 동작한다.

스케줄러의 주 기능은 마이크로태스크를 예약해 메인 스레드의 제어를 관리하고 원활한 실행은 보장하는 것이다.

리액트 코드베이스의 ensureRootIsScheduled 함수는 루트 스케줄에 루트가 포함되어있는지 확인하고, 루트 스케줄을 처리하기 위한 마이크로태스크가 대기 중인지 확인하는 역할을 수행한다.

여기서 말하는 마이크로 태스트를 이해하기 위해서는 자바스크립트의 이벤트 루프와 관련된 작업 큐의 기본 개념을 알아야 한다.

(자바스크립트 엔진의 동작원리 정리 참고: https://velog.io/@somda/FE-JavaScript-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95-Callback-Queue-Event-Loop)

**이벤트 루프**
* 자바스크립트 엔진의 이벤트 루프는 매크로태스크 큐와 마이크로태스크 큐라는 두 가지 작업 대기열에서 동작하며, 콜백 실행등 수행해야할 작업이 있는지 계속해서 확인함

**매크로태스크 큐**
* 이벤트 처리, setTimeout 콜백 실행 등의 작업이 저장되는 곳으로, 이 대기열의 작업은 한 번에 하나씩, 하나가 완료된 후에만 다음 작업이 실행됨

**마이크로태스크 큐**
* 더 작고, 즉각적인 작업으로 프라미스, Object.observe 등과 같은 연산에서 발생함.

**실행**
* 마이크로태스크는 현재 작업이 끝나고 자바스크립트 엔진이 작업 대기열에서 다음 매크로태스크를 선택하기 전에 처리됨. 마이크로태스크가 쌓여있으면 다 실행! (매크로태스크보다 마이크로태스크가 우선순위가 높다고 볼 수 있다.)

> 자바스크립트 엔진)
> 매크로태스크 → 실행 중에 등록된 마이크로태스크 → 마이크로태스크 다 처리 → 다음 매크로태스크 실행


다시 리액트와 ensureRootIsScheduled의 함수의 관점에서 보면, 마이크로태스크는 현재 스크립트 실행 직후, 브라우저가 렌더링이나 이벤트 처리 같은 작업을 수행하기 전 루트 스케줄의 처리가 높은 우선순위로 이루어지도록 보장하기 위해 사용한다.

> 리액트 & ensureRootIsScheduled)
> 현재 스크립트 → 루트 스케줄 (sort by 우선순위) → 렌더링 or 이벤트 처리

조금 더 자세히 정리한다면...

현재 JS 실행 →
  → 마이크로태스크 큐 실행 (Promise, queueMicrotask 등) →
    → React 루트 업데이트 예약 (ensureRootIsScheduled 내부 or 연관 함수들) →
      → Scheduler가 가장 시급한 작업 선택 →
        → 작업 수행 →
          → commit (DOM 변경) →
            → 브라우저가 paint(렌더링)


## 7.5 렌더레인

렌더레인은 리액트18에서 도입된 예약 시스템의 한 요소로, 작업의 렌더링과 우선순위 관리를 효율화 한다. (18 이전에는 만료 시간이 있는 예약 매커니즘이 사용되었다.)

**레인 예시 (우선순위 순서)**
* SyncHydrationLane: 하이드레이션 도중 사용자가 리액트 앱을 클릭한 이벤트가 배정되는 레인
* SyncLane: 리액트 앱을 클릭하면 클릭 이벤트가 배정되는 레인
* InputContinuousHydrationLane: 하이드레이션 도중 발생하는 호버, 스크롤 등 연속적 이벤트
* InputContinuousLane
* DefaultLane: 네트워크 업데이트, setTimeout같은 타이머 배정 레인
* TransitionHydrationLane: 하이드레이션 중 startTransition에서 발생하는 모든 트렌지션 
* TransitioLane
* RetryLanes: Suspense에서 발생하는 모든 재시도


**렌더 레인 작동 방식**
* 1. 업데이트 수집: 업데이트 수집 및 우선순위에 따라 레인 할당
* 2. 레인 처리: 업데이트 처리 (같은 레인의 업데이트는 일괄 처리)
* 3. 커밋 단계: 모든 업데이트 처리 후 변경 사항을 DOM에 적용하고 효과 실행


## 7.6 useTransition

컴포넌트에서 상태 업데이트의 우선순위를 관리하고, 우선순위가 높은 업데이트로 UI가 응답하지 않는 것을 방지하는 리액트 훅이다.
startTransition 함수로 감싸진 모든 업데이트는 트랜지션 레인에 들어가 낮은 우선순위를 부여할 수 있다.


## 7.7 useDeferredValue

특정 UI 업데이트를 나중으로 미루는 기 위해 사용되는 리액트 훅이다.
useDeferredValue의 첫 구현은 startTransition으로 상태 업데이트가 감싸진 형태였다.
(사용 예시: https://devsomda-practice.netlify.app/practice/useDefferedValue)

> [!NOTE]
> 리액트18 이후 useDefferred는 여전히 Transition 우선순위의 업데이트로 처리되지만 직접 startTransition()을 호출하지는 않는 방식으로 최적화 되었다.
>  React 내부에서 해당 deferred 상태를 “low priority”로 표시하고, React의 스케줄링 알고리즘이 적절한 시점에 처리한다.

useDeferredValue의를 사용하는 경우 사용자에게 표시되는 데이터가 최신 데이터가 아닐 수 있다는 것을 꼭 고려해야 한다.


## 7.8 동시 렌더링 관련 문제

동시성 렌더링은 성능과 응답성을 높이지만, 업데이트 처리 순서를 예측하기 어렵기에 예기치 않은 버그를 유발할 수 있다는 문제점이 존재한다.

### 7.8.1 티어링

티어링이란, 업데이트 순서가 어긋나며 UI가 일관성을 잃게 되는 일종의 버그다.

```js
function App() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <Sidebar count={count} />
      <MainContent count={count} />
      <button onClick={() => setCount(c => c + 1)}>증가</button>
    </div>
  );
}
```
여기서 count가 0 → 1로 바뀔 때,
React가 Concurrent Mode에서 두 컴포넌트를 “비동기적으로” 렌더링한다면?

	•	Sidebar는 새로운 값인 count = 1을 보여주는데,
	•	MainContent는 여전히 이전 값인 count = 0을 보여줄 수 있다.

(cf. 특히 useContext()를 사용하는 경우 Tearing 위험이 높아질 수 있다)

이를 해결하려면 useSyncExternalStore() 같은 훅으로 안정성 있는 상태 구독이 필요함







