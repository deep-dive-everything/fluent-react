# 7장. 리액트의 동시성

## 7.1 동기식 렌더링의 문제

### ❌ 동기식 렌더링의 문제점

- **메인 스레드를 차단**하여 사용자 인터랙션 지연 발생
- 결과적으로 **사용자 경험(UX) 저하**

### 🛠 기존 해결 시도: 일괄 처리

- 업데이트를 **일괄 처리**하여 효율성을 높이려 했으나, **우선순위 개념이 없어** 중요하지 않은 작업이 중요한 작업을 막아버리는 현상 발생 → 여전히 **UX 저하**

### ✅ 동시성 렌더링 (Concurrent Rendering)

- **업데이트 작업의 중요도와 긴급도**에 따라 **우선순위 부여**
- 많은 작업량에도 **UI 응답성 유지**, 사용자 경험 개선

### ⏱ 타임 슬라이싱 (Time Slicing)

- 렌더링 작업을 **작은 단위로 분할**하여 여러 프레임에 걸쳐 점진적으로 처리
- 필요 시 **작업 중단 후 우선순위 높은 작업 처리 가능**
    
    → 더욱 **유연한 작업 처리 및 사용자 인터랙션 보장**
    

## 7.2 파이버 다시 보기

### 🔧 파이버 재조정자 (Fiber Reconciler)

- **동시성 렌더링의 핵심 메커니즘**
- 렌더링 프로세스를 **작고 관리하기 쉬운 작업 단위인 파이버(Fiber)**로 분할하여 처리
- 파이버를 활용 시, 가능한 일:
    - 렌더링 작업 **일시 중지 및 재개**
    - 작업 **우선순위 설정**
    - **중요도에 따른 업데이트 예약 또는 지연**

✅ 결과적으로, UI가 크고 복잡한 리액트 앱에서

→ **높은 응답성 유지 가능**

→ **성능 개선 가능**

→ **우선순위 기반의 작업 처리 실현 가능**

7.3 업데이트와 예약 지연

애플리케이션의 응답성 유지하는데 매우 중요

파이버 재조정자는 업데이트 예약/지연을 스케쥴러와 여러 효율적인 API에 의존해 구현

스케줄러 : 해야할 업데이트 작업을 브라우저 API()를 이용해 작업을 예약, 관리하는 시스템

브라우저 API ⇒ 대기 시간 동안 작업 수행 가능, 가장 적절한 때에 업데이트 예약 가능

우선순위를 낮추고 싶다면 ⇒ useTransition, startTransition 함수로 감싸기

## 7.3 업데이트와 예약 지연

### ⚡ 응답성 유지의 핵심: 업데이트 스케줄링

- 사용자 인터랙션 중에도 **끊김 없는 UX**를 제공하려면, 업데이트 작업을 **적절한 시점에 예약/지연**하는 것이 중요

### 🧠 파이버 재조정자의 전략

- **업데이트 예약 및 지연** 기능은 다음에 의존해 구현됨:
    - **스케줄러**
    - **여러 브라우저 API**

### ⏳ 스케줄러란?

- 해야 할 업데이트 작업을 **브라우저 API**를 이용해 예약하고 관리하는 시스템
    
    (예: setTimeout, MessageChannel 등)
    
    - 이 API들을 조합하여:
        - **대기 시간 동안 다른 작업 수행 가능**
        - **작업을 가장 적절한 타이밍에 예약**

---

### ⬇ 우선순위를 낮추고 싶을 땐?

- 업데이트를 **낮은 우선순위로 처리하고 싶을 때** 사용할 수 있는 리액트 내장 함수: useTransition, startTransition 함수
- 이를 통해 **덜 중요한 작업은 뒤로 미루고**, **중요한 UI 응답은 즉시 처리 가능**

## 7.4 더 깊이 들어가기

## 7.4.1 스케줄러

### 📦 독립형 유틸리티 패키지

- **타이밍 관련 유틸리티**를 제공하는 **독립형 패키지**
- **파이버 재조정자와는 별개로 동작**
    
    → 기술적으로 모듈화되어 있으며, **내부 구현 공유는 최소화되었음을 의미**
    
    → 협력 관계
    

### 🤝 파이버와 스케줄러의 관계

- **리액트는 파이버 재조정자 내부에서 스케줄러를 사용**해 렌더링을 조율
- **협력 관계**이며, 다음과 같은 역할을 수행:
    - **렌더 레인(Render Lanes)**: 작업의 긴급도에 따라 우선순위를 설정

### 🛠️ 스케줄러의 주요 기능

- **마이크로태스크(루트 스케줄 작업이 우선순위 높게 실행**되도록 보장하기 위해 사용) **예약**을 통해:
    - 메인 스레드의 제어권을 세밀하게 관리
    - 전체적인 렌더링 흐름을 **원활하게 유지**

### 🔍 핵심 함수: ensureRootIsScheduled

- 리액트 루트에 대한 업데이트를 **효율적으로 관리**하는 데 중요한 역할
- **마이크로태스크를 전략적으로 예약**하여 렌더링이 막히지 않도록 돕는다
    
    ### 동작 과정
    
    1. **루트 스케줄에 해당 루트가 포함되어 있는지 확인**
        - 포함되어 **있지 않다면 마이크로태스크를 새로 예약**
        - 포함되어 **있다면 중복 예약을 방지**
    2. **(추가적으로)** 현재 대기 중인 마이크로태스크의 존재 여부 확인

## 7.5 [렌더 레인 (Render Lanes)](https://naver.me/Fuz4W8N9)

### 🛣 렌더 레인이란?

- 리액트의 **예약 시스템에서 핵심 요소**
- 작업의 **렌더링과 우선순위 관리를 효율화**
- Lane은 리액트가 렌더링 주기 동안 처리할 수 있는 **작업의 우선순위 수준**을 나타냄
    
    → 각각의 레인은 **서로 다른 우선순위에 대응**
    

## 7.5.1 렌더 레인의 작동 방식

### 🧩 기본 개념

- 컴포넌트의 업데이트 또는 **새로운 렌더 트리가 추가**될 때, 해당 작업은 **우선순위에 따라 특정 레인에 할당**됨

### ⚖ 우선순위는 무엇으로 결정되는가?

- **업데이트의 종류**: 예) 사용자 상호작용, 데이터 패치, 백그라운드 동기화 등
- **컴포넌트의 가시성**: 화면에 보이는지 여부 등에 따라 다름
- 내부 휴리스택(직관적인 규칙) + 업데이트 발생 콘텍스트 기반

### 🔁 렌더 레인의 처리 단계

### **업데이트 예약 및 우선순위 선정 방식**

1. **업데이트 수집**
    - 마지막 렌더링 이후 발생한 모든 업데이트를 수집
    - 각 업데이트를 우선순위에 따라 **해당 레인에 할당**
2. **레인 처리**
    - **우선순위가 높은 레인부터 처리**
    - 동일한 레인에 있는 업데이트는 **일괄 처리**
3. **커밋 단계**
    - 계산된 결과를 실제 DOM에 반영
4. **필요 시 반복**
    - 남은 작업이 있다면 **다시 수집 → 처리 → 커밋** 반복

### 🧠 업데이트의 우선순위 및 레인 할당 방식

1. **업데이트 콘텍스트 확인**
2. **콘텍스트에 따라 우선순위 추정**
3. **우선순위 재정의 여부 확인**
4. **해당 레인에 업데이트 할당**

## 7.5.2 레인 처리

## 7.5.3 커밋 단계

## 7.6 useTransition

## 7.6.1 간단한 예시

## 7.6.2 고급 예시 : 페이지 탐색

## 7.6.3 더 깊이 들어가기

## 7.7 useDefferedValue

## 7.7.1 useDefferedValue 의 목적

## 7.7.2 useDefferedValue 사용 시기

## 7.7.3 useDefferedValue가 적합하지 않은 경우

## 7.8 동시성 렌더링 관련 문제

## 7.8.1 티어링
