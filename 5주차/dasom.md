# 5장 자주 묻는 질문과 유용한 패턴

2025.03.16 dasom

## 5.4 useState와 useReducer
흔히 단일 상태 관리에서 useState, 복잡한 상태 관리에서 useReducer를 사용한다.
(사실 useState가 내부적으로 useReducer를 사용한다.)

useReducer 사용의 이점
* 상태 업데이트 로직을 컴포넌트에서 분리하여, 단일 책임 원칙을 따르기에 좋음
* 상태와 상태 변경 방식은 항상 명시적으로 useReducer와 함께 사용됨 (따라서 어떤 이들은 useState가 JSX트리 계층을 통한 컴포넌트 상태 업데이트의 전반적 흐름을 파악하기 힘들게 한다고 말함)
* useReducer는 이벤트 소스 모델로, 어플리케이션에서 발생하는 이벤트를 모델링해, 일종의 진단 로그를 추적하는 데 사용할 수 있음 (e.g. 시간 여행 디버깅 등)

useState와 useReducer 사용은 복잡성에 따라 결정할 수 있다


* Immer
  * 변경 가능한 초안 상태로 작업하고, 한 번 생성된 상태는 변경 불가로 만들어 복잡성을 관리할 수 있도록 도와줌
  * useReducer로 작업할 때 제공하는 리듀서 함수는 순수해야 하며 항상 새 상태 객체를 반환해야함 (때문에 중첩된 상태 객체를 처리할 때 코드가 길어질 수 있음)
    이때 useImmerReducer를 통해 단순하고 직관적 리듀서 함수를 작성할 수 있다 (참고로 immer는 useState와 함께 사용할 수도 있다)


## 5.5 강력한 패턴
소프트웨어 디자인 패턴이 중요한 이유
* 재사용성, 표준화, 유지 보수성, 효율성

리액트 디자인 패턴
* 프레젠테이션/컨테이너 컴포넌트
* 고차 컴포넌트
  * 여러 컴포넌트에서 공유하는 동작을 반복 작성하고 싶지 않을 때 유용
* 고차 컴포넌트 합성
  * 고차 컴포넌트는 훅의 등장 이후 인기가 식음
* 렌더 프롭
  * 자식 -> 부모로 제어를 역전하지만 훅의 등장으로 역시 대체 됨
* 제어 프롭
* 프롭 컬렉션
* 복합 컴포넌트
  * 자식이 콘텍스트 상태를 인식하게 하면서 동시에 렌더링 제어를 부모에게 넘김 & 상태와 관심사 분리가 가능해져 애플리케이션의 확장성이 높아짐  
* 상태 리듀서
  * 리듀서 훅을 사용해 컴포넌트 자체를 변경하지 않고도 컴포넌트 동작을 유연하게 수정할 수 있음




