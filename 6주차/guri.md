# 1. 클라이언트 사이드 렌더링 한계

- 클라이언트 사이드 렌더링 접근 방식의 한계로 더 많은 관심사를 서버 사이드로 이전하게 됨

## 1.1 검색 엔진 최적화(SEO)

- 일부 검색 엔진의 크롤러가 자바스크립트를 실행하지 않음
- 자바스크립트를 실행하는 크롤러도 예상대로 실행되지 않을 수 있음

 ⇒ 콘텐츠를 올바르게 색인하지 못하는 문제 발생

- 검색 엔진 크롤러의 구현 방식이 다양하고 상당수가 공개되지 않아 클라이언트 사이드 렌더링은 특정 웹사이트나 애플리케이션이 수집되는 범위에 대해서 명확하지 않은 부분이 있음.
- HTML은 페이지의 모든 콘텐츠를 마크업 텍스트로 나타낸 것으로 검색 엔진 크롤러가 콘텐츠를 쉽게 읽고 색인을 생성할 수 있음.
- 그러나 클라이언트 사이드 렌더링 애플리케이션에서는 서버가 거의 비어 있는 HTML파일을 전송함

## 1.2 성능

- 느린 네트워크나 낮은 성능의 기기에서 성능 문제가 있을 수 있음
- 콘텐츠 렌더링 전에 자바스크립트를 다운로드 하고 구문 분석과 실행까지 해야하기 때문에 렌더링이 지연 될 수 있음
    
    ⇒ 사용자 이탈율이 높아지고 검색엔진 순위에 부정적 영향을 미침
    
- 자바스크립트를 실행하는 기기의 처리 능력이 부족해 애플리케이션이 느리게 동작하거나 응답하지 못할 수 있음.
- 서버에서 자바스크립트를 먼저 실행하고 최소한의 데이터나 마크업을 클라이언트로 전송하면 사용자 경험이 개선될 수 있음.
- 네트워크 폭포 현상 : 웹사이트나 웹 애플리케이션을 표시하기 위해 브라우저가 다운로드, 파싱, 실행해야아하는 자바스크립트 때문에 초기 페이지 로드가 차단되는 현상.
- 서버사이드 렌더링을 사용하면 네트워크 폭포 현상 없이 처을 페이지를 로딩하는 순간부터 사용자가 콘텐츠를 바로 볼 수 있음.

## 1.3 보안

- 클라이언트 사이드 렌더링은 모든 코드가 브라우저로 다운로드되어 크로스 사이트 요청 위조(CSRF)같은 공격에 취약함.
- 서버에 접근할 수 있고 웹 앱이 클라이언트 전용일때 토큰 검증 방식으로 보안을 강화할 수 있음.
- 이때 서버 사이드 렌더링을 고려할 필요가 있음.

# 2. 서버 렌더링의 부상

- 서버 렌더링을 사용하면 애플리케이션을 속도와 접근성에 맞게 최적화해 로딩 시간을 단축하고 SEO를 개선하며 사용자 참여도를 높일 수 있음

## 2.1 서버 렌더링의 장점

- first meaningful paint가 완성되는 시간이 더 빨라짐
    - 네트워크폭포 현상 없이 서버가 초기 HTML마크업을 렌더링해 클라이언트로 전송하여 바로 콘텐츠를 볼 수 있음.
- 웹 애플리케이션의 접근성 개선
    - 인터넷 연결 속도가 느리거나 저전력 기기를 사용하더라도 완전히 렌더링 된 HTML을 받기 때문에 사용자 경험이 향상됨.
- 웹 애플리케이션의 SEO를 개선
    - 완전히 렌더링 된 HTML을 볼 수 있으므로 검색엔진 크롤러가 색인을 생성하기 용이함
- 웹 애플리케이션의 보안 향상

# 3. 하이드레이션

- 하이드레이션 : 서버에서 생성되어 클라이언트로 전송되는 정적 HTML에 이벤트 리스너와 자바스크립트 기능을 추가하는 프로세스.
- 하이드레이션의 목적 : 브라우저가 서버 렌더링 애플리케이션을 읽은 후 여기에 상호 작용을 추가해 사용자에게 원활한 경험 제공.
- 하이드레이션은 클라이언트가 서버에서 렌더링된 리액트 애플리케이션을 다운로드한 후 발생
    - 클라이언트 번들 로딩
        - 정적 HTML을 렌더링하는 동안 자바스크립트 번들을 다운로드하고 파싱함.
    - 이벤트 리스너 추가
        - 자바스크립트 번들이 로드되면 리액트는 이벤트 리스너 및 기타 동적 기능을 DOM 요소에 추가해 정적 HTML을 하이드레이션함. hydrateRoot 함수를 사용해 수행됨.
- 하이드레이션이 완료되면 애플리케이션은 완전한 인터렉티브 리액트 애플리케이션으로 변환됨.

## 3.1 하이드레이션에 대한 비판

- 하이드레이션이 필요 이상으로 느리다는 비판 + 대안으로 재개 가능성을 제기하는 입장
- 하이드레이션을 사용하면 애플리케이션을 우선 렌더링 한 후 클라이언트 번들을 다운로드하고 이벤트 리스너를 추가하는 과정이 그 이후에 이루어짐. 그 뒤 클라이언트를 리렌더링해야함.
    - 이 과정이 많은 작업을 필요로 하고 콘텐츠가 사용자에게 표시되는 시점과 사용자가 실제로 사이트를 사용할 수 있는 시점 사이에 지연이 발생하게 함.
- 재개 가능성을 활용하면, 마크업과 모든 인터렉티브 동작이 직렬화되어 클라이언트로 전송됨. 하이드레이션 과정을 생략할 수 있으므로 인터렉티브 시간이 짧아지고 사용자 경험이 향상됨.

⇒ 재개 가능성의 장점이 있지만, 하이드레이션보다 구현이 복잡함. 장점이 비용보다 큰지 명확하지 않음.

# 4. 서버 렌더링 작성

- 서버 렌더링 프레임워크(Next.js, Remix) 사용 권장

## 4.1 클라이언트 전용 리액트 앱에 서버 렌더링을 수동으로 추가하기

```jsx
//server.js

const express = require("express");
const path = require("path");
const React = require("react")

const ReactDOMServer = require("react-dom/server");

const App = require("./src/App");

const app = express();

app.use(express.static(path.join(__dirname, "build")));

app.get("*", (req, res) => {
  const html = ReactDOMServer.renderToString(<App />);

  res.send(
    <DOCTYPE html>
    <html>
      <head>
        <title>예시 리액트 어플리케이션</title>
      </head>
      <body>
        <div id="root">${html}</div>
        <script src="/static/js/main.js"></script>
      </body>
    </html>
  );
});

app.listen(3000, ()=> {
  console.log("Server listening on port 3000")
})
```

- 이 예시에서는 Express를 사용해 ./build 디렉터리에서 정적 파일을 서비스하는 서버를 생성한 다음, 서버에서 리액트 앱을 렌더링함.
- ReactDOMServer를 사용해 리액트 앱을 HTML 문자열로 렌더링 한 다음 클라이언트로 전송되는 응답에 삽입함.

## 4.2 하이드레이션

- 서버에서 렌더링된 출력 결과가 사용자에게 전달되고, 파일 끝부분의 <script> 태그를 통해 클라이언트 번들을 로드할 때 하이드레이션이 발생함.

```jsx
import React from "react";
import { hydrateRoot } from "react-dom/client"
import App from "./App";

//클라이언트사이드에서 애플리케이션을 하이드레이션함
hydrateRoot(document, <App />);
```

# 5. 리액트의 서버 렌더링 API

## 5.1 renderToString

- 리액트에서 제공하는 서버 사이드 렌더링 API.
- 동기식으로 동작. 완전히 렌더링 된 HTML문자열을 반환

**사용법**

- react-dom/server 패키지에서 renderToString 함수를 가져와야함.
- 리액트 컴포넌트를 인수로 전달하여 호출하면 완전히 렌더링된 HTML문자열을 받을 수 있음

```jsx
import React from "react";
import { renderToString } from "react-dom/server";

function App() {
  return {
    <div>
	    <h1>안녕하세요</h1>
	  </div>
	};
}

const html = renderToString(<App />);
console.log(html);
```

**작동방식**

- 이 함수는 리액트 엘리먼트의 트리를 탐색하고 이를 실제 DOM엘리먼트에 해당하는 문자열 표현으로 변환한 다음 전체 문자열을 결과로 반환함
- JSX의 HTML변환 과정

```jsx
JSX -> React.createElement -> React 엘리먼트 -> renderToString(React element) -> HTML
```

- renderToString은 동기식 API이므로 실행이 중단되거나 일시적으로 중지될 수 없음.
- 대상이 되는 컴포넌트의 depth 가 많을수록 처리 시간이 걸릴 수 있음.
- 캐시와 같은 적절한 방지책이 없다면 모든 클라이언트에서 rederToString이 호출되어 이벤트 루프의 진행을 가로막고 시스템이 과부하될 수 있음.

**단점**

- 성능
    - 대규모 애플리케이션에서 처리속도가 느릴 수 있음
    - 동기식이기 때문에 이벤트 루프를 차단하고 서버가 응답하지 않을 수 있음
    - 완전히 렌더링된 HTML을 반환하므로 메모리 사용량이 과도할 수 있음. 메모리 사용량 증가로 응답 시간이 느려지거나 과부하 상태에서 서버 프로세스가 중단되는 패닉 상태에 이름
- 스트리밍 지원 부족
    - renderToString은 스트리밍을 지원하지 않으므로 HTML문자열 전체를 생성함.
    - 클라이언트가 HTML수신을 시작하기까지 오래 걸릴 수 있음.
    - HTML문자열 전체를 생성하기까지 대기한 후 클라이언트가 콘텐츠를 표시할 수 있음.

## 5.2 renderToPipeableStream

- renderToPipeableStream은 리액트 18에 도입된 서버사이드 렌더링 API
- 대규모 리액트 애플리케이션을 Node.js 스트림에 렌더링하는 효율적인 방법

**작동 방식**

- 응답 객체로 Node.js스트림을 반환함.
- 스트림을 사용하면 전체 데이터를 메모리에 한꺼번에 읽어들이는 대신 청크 단위로 점진적으로 처리함.
- 대용량 문자열이나 데이터 스트림을 다룰때 특히 유용함.

**Node.js 스트림**

- Node.js스트림은 출발지에서 목적지로 흐르는 데이터 흐름을 나타냄
- 종류
    - 읽기 가능 스트림
    - 쓰기 가능 스트림
    - 양방향 스트림
    - 변환 스트림
- 스트림 간에 데이터를 파이프 하는 기능 : 파이프를 사용하면 읽기 가능한 스트림의 출력을 쓰기 가능한 스트림의 입력에 직접 연결해서 데이터 흐름이 원활해짐.
    
    ⇒ 처리 프로세스 간소화, 메모리 사용량 줄어듬.
    

**리액트의 RenderToPipeableStream**

- RenderToPipeableStream은 리액트 서버 랜더러의 일부로, 리액트 애플리케이션을 Node.js 스트림으로 스트리밍 렌더링 할 수 있도록 설계되었음.

**요청생성**

- RenderToPipeableStream함수는 랜더링할 리액트 엘리먼트와 선택적인 옵션 객체를 인수로 전달받음.
- 이후 createRequestImpl 함수를 사용해 요청 객체를 생성.
- 이 요청 객체는 리액트 엘리먼트, 리소스, 응답 상태, 포켓 콘텍스트를 캡슐화함

**작업시작**

- 요청 객체를 인수로 startWork함수를 호출해 렌더링 프로세스를 시작함
- suspense : 렌더링 중 비동기 데이터 패치를 잘 처리해주는 기능
- suspense로 감싸진 컴포넌트는 비동기 데이터가 준비되면 점진적으로 추가되는 방식으로 구현 가능함. 다른 중요한 UI를 먼저 표시할 수 있음
- 사용자가 즉시 의미있는 컨텐츠를 볼 수 있고 많은 데이터가 확보되는 대로 점진적으로 페이지를 향상시킬 수 있음.

**파이프 가능 스트림으로 반환**

- RenderToPipeableStream은 pipe 메서드와 abort 메서드를 포함하는 객체를 반환함
- pipe 메서드는 렌더링된 출력을 쓰기 가능 스트림으로 전달함.
- abort 메서드는 대기중인 모든 입출력 작업을 취소하고 남은 작업을 클라이언트 렌더링 모드로 전환하는데 사용함

**목적지로 파이핑**

- pipe 메서드가 목적지 스트림과 함께 호출되면 데이터가 전송되기 시작했는지 확인함.

**스트림 이벤트 처리**

- 목적지 스트림이 더 많은 데이터를 수신할 준비가 되면 drain 이벤트 핸들러는 startFlowing을 호출해 데이터 흐름을 제개함.
- 목적지에서 오류가 발생하거나 조기 종료되면 abort함수를 호출해 렌더링 프로세스를 중지함

**렌더링 중단**

- abort 메서드를 호출할 때 렌더링 프로세스를 중단하는 이유를 전달할 수 있음.

**RenderToPipeableStream의 기능**

- 스트리밍
    - 파이프 가능한 Node.js 스트림을 반환함
- 유연성
    - HTML이 렌더링 되는 방식을 더 세밀하게 제어할 수 있음.
- Suspense 지원
    - 비동기 데이터 패치와 지연로딩 관리. 이 데이터에 의존하는 컴포넌트만 따로 관리

## 5.3 renderToReadableStream

- renderToPipeableStream과 유사하지만, 브라우저 스트림을 반환함.

**Node.js스트림과 브라우저 스트림**

| 구분 | Node.js 스트림 | 브라우저 스트림 |
| --- | --- | --- |
| 작동 환경 | 파일 입출력, 네트워크 입출력, 종단간 스트리밍을 다루는 서버 환경 | 웹 브라우저 내의 클라이언트 환경 |
| API | Node.js에 맞춰 작성된 API | WHATWG에서 정의한 스트림 표준 |
| 데이터 처리 방식 | 읽기 가능, 쓰기 가능, 양방향, 변환 스트림 각각에 클래스가 있음 | read(), write(), pipeThrough()등의 메서드를 사용 |

## 5.4 언제 무엇을 사용해야 하나요?

- rederToString은 동기식으로 동작하기 때문에 적합하지 않을 때가 있음
- RenderToPipeableStream과 RenderToReadableStream은 이를 보완한 비동기 스트림 기반 방식이며 각각 서버 네이티브, 브라우저 네이티브 방식이기 때문에 환경에 따라 선택하면 됨.
- 현재 사용중인 많은 서드파티 라이브러리(데이터 패치, css관련)들이 이런 API와 호환되지 않음
    
    ⇒ 서버에서 렌더링이 완료되지 않은 채 브라우저에서 부분적으로 하이드레이션 해야하는 사례를 지원하지 않음
    
- 상황에 따라 다르다 or 그냥 프레임워크 써라

# 6 직접 구현하지 마세요

- 처음부터 직접 서버 렌더링을 구현하면 비효율적이고 여러 문제 발생
- 그냥 프레임워크 써라 방법이 더 나은 이유를 살펴봅시다(Next.jst, Remix)

**에지 케이스 및 복잡성 처리**

- 비동기 데이터 패치, 코드 분할, 리액트 수명주기 이벤트 관리 등 다양한 에지 케이스를 해결해야함.
- 프레임워크에는 에지 케이스에 대한 해결책이 포함되어있음. 복잡성을 직접 처리할 필요 x
- 보안을 염두에 두고 설계되었기 때문에 안전하고 격리된 데이터 패치 방식을 사용해 유출 가능성을 미연에 방지

**성능 최적화**

- 자동 코드 분할, 서버 렌더링, 캐싱 등의 성능 최적화 기능을 기본으로 제공

**개발자 경험 및 생산성**

- 직접 구현하면 시간 짱많이 걸림 ⇒ 프레임워크 사용하면 기본 서버 렌더링 인프라는 신경쓰지 않고 애플리케이션 기능 구현에 집중할 수 있음.
- 생산성 향상과 개발자 경험 개선

**모범 사례와 코딩 규칙**

- 모범 사례를 염두에 두고 설계된 프레임워크이므로 여기서 제안한 코딩 규칙을 따르면 탄탄한 기반에서 애플리케이션을 작성할 수 있음.
