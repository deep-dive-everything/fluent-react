## 클라이언트 사이드 렌더링(CSR)의 한계

### 검색 엔진 최적화(SEO)

> _클라이언트 사이드 렌더링은 검색 엔진 크롤러가 콘텐츠를 올바르게 색인하지 못할 가능성이 있다._

- 기존 웹 애플리케이션
  - 사용자나 검색 엔진 크롤러가 페이지를 요청하면 서버가 해당 페이지의 HTML을 렌더링해서 다시 전송
  - HTML에는 페이지의 모든 콘텐츠가 텍스트, 즉 마크업에 불과
  - 검색 엔진 크롤러가 검색 엔진 결과를 위해 콘텐츠를 쉽게 읽고 색인을 생성할 수 있음
- 클라이언트 전용 애플리케이션
  - 서버가 거의 `비어 있는 HTML 파일`을 전송
  - `비어 있는 HTML 파일` → 서버에 있는 별도의 파일에서 자바스크립트를 읽어 들이기
  - 자바스크립트 파일이 다운로드 되고 브라우저에서 실행되어 페이지 콘텐츠가 동적으로 렌더링

### 성능

> _자바스크립트의 역할은 웹 페이지를 보완해 개선하는 것이지 웹 페이지 그 자체가 되는 것이 아닙니다._

> [!NOTE]
>
> #### 웹 성능 주요 지표
>
> - First Contentful Paint(FCP): 사용자가 처음으로 화면에서 콘텐츠를 볼 수 있게 되는 시점
> - Speed Index(SI): 페이지가 시각적으로 얼마나 빠르게 로드되는지를 측정하는 지표
> - Largest Contentful Paint(LCP): 페이지에서 가장 큰 콘텐츠가 로드되는 시점
> - Time To Interactive(TTI): 페이지가 완전히 상호작용할 수 있는 상태가 되는 시점
> - Total Blocking Time(TBT): 메인 스레드가 50ms 이상 블로킹된 시간의 합
> - Cumulative Layout Shift(CLS): 페이지 로딩 중 발생하는 예상치 못한 레이아웃 변경 정도

- 클라이언트 사이드 렌더링은 네트워크 폭포 현상을 발생시킴

> [!NOTE]
>
> #### 네트워크 폭포 현상(Network Waterfall Effect)
>
> 브라우저가 웹페이지를 로드하는 과정에서 다운로드, 파싱, 실행해야 하는 자바스크립트로 인해 초기 페이지 로드가 차단되는 현상

- 해결책: 기본적인 핵심 콘텐츠 + 애니메이션과 같은 고급 기능
  - 핵심 콘텐츠는 서버 사이드 렌더링 → 모든 사용자와 검색 엔진이 필요한 정보를 즉각 접근 가능
  - 상호작용 및 애니메이션은 클라이언트 사이드 렌더링 → 사용자 경험 향상

#### 🤔 CSR과 SSR의 데이터 페치 요청 비교

- 클라이언트 사이드 데이터 페치 요청
  ```
  HTML 로딩(빈 페이지) → JS 로딩 → 초기 UI 렌더링 → 데이터 가져오기(fetch) → UI 업데이트
  ```
  - HTML 로딩~데이터 가져와서 UI 업데이트까지 사용자가 기다려야 하는 시간이 너무 김
- 서버 사이드 데이터 페치 요청
  ```
  HTML 로딩(전체 UI, 서버에서 가져온 데이터 포함) → JS 로딩 …
  ```
  - 성능 개선: 네트워크 폭포 현상이 없으며, 사용자는 모든 정보를 즉각 얻을 수 있음
  - 사용자 환경 개선: 서버에서 자바스크립트를 먼저 실행하기 때문에 저전력 클라이언트가 많은 작업을 수행할 필요가 없음

#### 🤔 그럼 리액트는?

- 리액트(6.4KB) + 리액트 DOM(130.2KB) ⇒ 약 136KB
- 리액트가 DOM 전체 제어하기 때문에 `리액트 + 리액트 DOM`을 먼저 전부 다 읽어 들일 때까지 기다려야 함

#### 🤔 이러한 문제를 해결하려면?

- `스트리밍 → 하이드레이션`
  - 스트리밍: 자바스크립트가 다운로드되기 전에 렌더링된 HTML을 클라이언트로 스트리밍
  - 하이드리이션: 페이지가 최초 렌더링된 후 자바스크립트를 읽어 들이기
- 렌더링된 HTML을 처음 **스트리밍** → 자바스크립트로 DOM에 **하이드레이션**
  - 더 빨리 상호 작용 + 추가 로딩 대기 없음 ⇒ **사용자 경험 향상 🥳**

### 보안

> 클라이언트 사이드 렌더링은 민감한 데이터 처리 시 보안이 문제시 될 수 있다.

- 애플리케이션의 모든 코드가 클라이언트의 브라우저로 다운로드하는 CSRF 공격에 취약

클라이언트 사이드 렌더링에서 CSRF 위험이 발생할 수 있는 이유

- 서로를 알지 못하는 클라이언트와 서버
  - 서버와 클라이언트 간에 공유하는 공통 비밀이나 계약이 없기 때문에 CSRF 공격에 취약할 수 있음
  - 서버가 요청이 어디서 온 것인지 확인하지 않으면 잘못된 요청에 그대로 속을 수 있음

안전한 양방향 계약 설정 가능한 서버 렌더링

- 서버에서 컴포넌트를 렌더링할 때 서버에서 생성된 특수한 비밀 토큰 사용
- 비밀 토큰이 포함된 HTML을 클라이언트로 전송 → 클라이언트는 이 토큰을 발급한 서버로 다시 전송
- 보안 문제 완화
- 서버는 악의적인 공격자일 가능성이 있는 정체불명의 클라이언트가 아니라, 사전 승인한 올바른 클라이언트에서 요청이 온 것인지 검증할 수 있음

> _서버를 제어할 수 있는 상황이라면, 굳이 서버 사이드 렌더링을 추가하지 않을 이유가 있을까요?_

## 서버 렌더링의 장점

- **성능**: 최초 의미 있는 페인트(FCP)가 완성되는 시간이 빨라짐
- **접근성**: 인터넷이 느리거나 저전력 기기를 사용하더라도 사용자가 화면을 볼 수 있어 사용자 경험이 향상됨
- **SEO**: 완전히 렌더링된 HTML을 볼 수 있어 검색 엔진 크롤러 웹페이지를 인식할 수 있음
- **보안**: 서버와 클라이언트 간의 양방향 계약 설정이 가능해 CSRF 공격 등을 방지할 수 있음

## 하이드레이션

> 서버에서 생성되어 클라이언트로 전송되는 정적 HTML에 이벤트 리스너와 여러 자바스크립트 기능을 추가하는 프로세스로 클라이언트가 서버에서 렌더링된 리액트 애플리케이션을 다운로드한 후 발생

#### 목적

- 브라우저가 서버 렌더링 애플리케이션을 읽어 들인 후 여기에 상호 작용을 추가해서 사용자에게 빠르고 원활한 경험을 제공하는 것
- 리액트는 하이드레이션을 하면서 정적 HTML의 DOM 엘리먼트 구조를 리액트 컴포넌트가 JSX를 사용해 정의한 구조와 일치시킴
- 불일치한다면..? → 애플리케이션이 예상대로 동작하지 않음 😭
  - 리액트는 이벤트 리스너를 올바르게 연결할 수 없음
  - 리액트 엘리먼트가 어떤 DOM 엘리먼트에 직접 매핑되어야 하는지 인식 못함

#### 순서

```
(1) 클라이언트가 서버에서 렌더링된 애플리케이션 다운로드 → (2) 클라이언트 번들 로딩 → (3) 이벤트 리스너 추가
```

- (2) 클라이언트 번들 로딩에는 리액트 컴포넌트와 애플리케이션의 기능에 필요한 코드 포함됨
- (3) JS 번들 로드 후, 이벤트 리스너 및 기타 동적 기능을 DOM 요소에 추가해 정적 HTML을 하이드레이션
  - 루트 리액트 컴포넌트와 DOM 컨테이너를 인수로 받는 `hydrateRoot` 함수를 사용해 수행
  - 하이드레이션이 완료되면 정적 HTML이 완전한 인터랙티브 리액트 애플리케이션으로 변환

### 재개 가능성

> 하이드레이션이 필요 이상으로 느리다!

#### 하이드레이션의 동작 방식

- 서버에서 리액트 애플리케이션 먼저 렌더링, 렌더링된 출력을 클라이언트에 전달 (인터랙티브 기능 X)
- 브라우저는 클라이언트 번들 다운로드 및 이벤트 리스너 추가 → **클라이언트 리렌더링**
- 리렌더링 하는 과정에서 콘텐츠가 사용자에게 표시되는 시점과 사용자가 실제로 사이트를 사용할 수 있는 시점 사이에 지연 발생

> 재개 가능성을 활용하면 하이드레이션의 지연 문제를 보완할 수 있다.

#### 재개 가능성의 동작 방식

- 전체 애플리케이션이 서버에서 렌더링되어 브라우저로 스트리밍
- 초기 마크업 + 모든 인터랙티브 동작 → **직렬화(serealized)**되어 클라이언트로 전송
- 이 시점에서 클라이언트는 이미 인터랙티브해지는 방법에 대한 모든 정보를 가지므로 서버가 중단한 부분부터 다시 재개 가능
- 즉, 하이드레이션(이벤트 리스너 연결 + 클라이언트 사이드 페이지 렌더링)할 필요 없이 서버가 제공한 내용을 역직렬화해 그에 따라 반응
- 하이드레이션 단계를 건너뛰면 인터랙티브 시간(TTI)이 짧아지고 사용자 경험 향상

#### 하이드레이션 vs 재개 가능성

- 재개 가능성이 TTI가 더 빠르긴 하지만 구현에 따르는 복잡성을 감수할 가치가 있는지? → 의문인 상태

## 리액트의 서버 렌더링 API

### `renderToString`

> 리액트 v19 공식문서에서는 이미 `renderToString`을 레거시로 분류중..

- 서버에서 리액트 트리를 HTML 문자열로 렌더링
- 동기식으로 동작하며, 완전히 렌더링된 HTML 문자열을 반환

#### 함수 시그니처

```tsx
const html = renderToString(reactNode, options?)
```

- 매개변수
  - `reactNode`: HTML로 렌더링할 리액트 노드
  - `options?`: 서버 렌더링을 위한 객체
- 반환값: HTML 문자열

#### 작동 방식

```
JSX → React.createElement → React 엘리먼트 → renderToString(React element) → HTML
```

- 리액트 엘리먼트의 트리를 탐색하고 이를 실제 DOM 엘리먼트에 해당하는 문자열 표현으로 변환한 다음, 전체 문자열을 결과로 반환

#### 단점

- 성능
  - 동기식 → 이벤트 루프를 차단하고 서버가 응답하지 않게 만들 수 있음
  - 완전히 렌더링된 HTML 문자열을 반환 → 과도한 메모리 사용량 발생 가능
  - 캐시와 같은 적절한 방지책이 없다면, 일반적으로 클라이언트와 1:N 관계인 서버 특성상 모든 클라이언트에서 `renderToString`이 호출되어 이벤트 루프의 진행을 가로막고 시스템 과부화 발생할 수 있음
- 스트리밍을 지원하지 않음 (Legacy Sever APIs for non-streaming environments)
  - 클라이언트로 전송하려면 HTML 문자열 전체를 생성해야 함
  - 느린 첫 번째 바이트 시간(FTTB) → 클라이언트가 HTML 수신에 오랜 시간이 걸림
  - 콘텐츠가 많은 대규모 애플리케이션에서 사용이 적절하지 않음

> 이러한 단점을 해결하기 위해 `renderToPipeableStream`, `renderToReadableStream` 등의 API 제공

### `renderToPipeableStream`

> Node.js 스트림을 이용하여 리액트를 그리는 서버 API

#### 함수 시그니처

```tsx
const { pipe, abort } = renderToPipeableStream(reactNode, options?)
```

- 매개변수
  - `reactNode`: HTML로 렌더링하려는 리액트 노드
  - `options?`: 스트리밍 옵션을 지정할 수 있는 객체
- 반환값: 두 개의 메서드가 있는 객체 반환
  - `pipe`: HTML을 제공된 쓰기 가능한 **Node.js 스트림**으로 출력
  - `abort`: 서버 렌더링을 중단하고, 나머지는 클라이언트에서 렌더링

> [!NOTE]
>
> ### Node.js 스트림
>
> 출발지에서 목적지로 흐르는 데이터의 흐름 → _데이터가 흐르는 도관_
>
> - 스트림으로 전체 데이터를 메모리에 한꺼번에 읽어 들이는 대신 청크 단위로 점진적으로 처리 가능
>
> #### 스트림 종류
>
> - 읽기 가능 스트림
>   - 읽을 수 있는 데이터 출처를 나타내며 `data`, `end`, `error` 같은 이벤트 발생시킴
>   - 예) 파일에서 데이터 읽기, HTTP 요청에서 데이터 수신, 사용자 정의 데이터 생성기를 사용한 데이터 생성 등
> - 쓰기 가능 스트림
>   - 데이터를 쓸 수 있는 대상을 나타내며, 스트림으로 데이터를 전송하는 `write()`, `end()` 같은 메서드 제공
>   - 대상이 더 많은 데이터를 처리해야 하는 상황 → `drain` 이벤트 발생
>   - 쓰기 중 오류가 발생 → `error`이벤트 발생
>   - 예) Express의 `res` 응답 객체
> - 양방향 스트림
>   - 동시에 읽기 가능한 스트림도 되고 쓰기 가능한 스트림도 되는 스트림
>   - 양방향 데이터 흐름을 허용 → 스트림에서 읽고 쓰기가 가능
>   - 예) 네트워크 소켓, 통신 채널 등에 사용
> - 변환 스트림
>   - 데이터가 흐르는 동안 데이터 변환을 수행하는 특수한 양방향 스트림
>   - 입력 데이터를 읽고 처리한 후 처리된 데이터를 출력으로 제공
>   - 예) 압축, 암호화, 압축 해제 또는 데이터 구문 분석 등에 사용
>
> #### 파이프
>
> 스트림 간에 데이터를 파이프
>
> - 읽기 가능한 스트림의 출력을 쓰기 가능한 스트림의 입력에 직접 연결해서 원활한 데이터 흐름 가능
> - 데이터 처리 프로세스 간소화 및 메모리 사용량 감소
>
> #### 백프레셔 처리 지원
>
> - 백프레셔: 데이터 전송 중에 발생하는 문제로, 버퍼 뒤에 데이터가 쌓이는 현상
> - 쓰기 가능 스트림이 데이터를 충분히 빠르게 처리하지 못할 경우
>   - 읽기 가능 스트림에서 `data` 이벤트 발생을 일시적으로 중지해 데이터 손실 방지
> - 쓰기 가능 스트림이 추가 데이터를 처리할 준비 완료 시
>   - `drain` 이벤트를 발생 → 읽기 가능 스트림이 데이터 전송을 재개하도록 신호 전달
>
> > Node.js 스트림은 메모리를 효율적으로 처리할 수 있는 확장 가능하고 강력한 추상화 기능 제공하여, 대용량 데이터 세트, 파일 입출력 작업, 네트워크 통신 등 효율적으로 처리 가능

- HTML이 렌더링되는 방식을 더 세밀하게 제어 가능해 더 쉽게 다른 Node.js 스트림과 통합 가능
- 리액트의 동시성 기능, 특히 서버 사이드 렌더링 중 비동기 데이터 페치를 더 잘 처리해주는 Suspense 지원
- 스트림이기 때문에 네트워크를 통해 스트리밍할 수 있으며, HTML 청크를 클라이언트에 비동기적으로 전송
  - 네트워크 지연 없는 점진적인 데이터 전달 가능
- 첫 번째 바이트 시간(TTFB) 지표 향상 및 전반적인 성능 개선
  - 쓰기 가능 스트림으로 스트리밍 → HTML 응답 청크가 준비되는 즉시 전송 시작 → 지연 시간 감소
- `renderToOPipeableStream`은 **`Fizz`라고 불리는 리액트 서버 렌더러 아키텍처의 일부**
  - 리액트 애플리케이션을 Node.js 스트림으로 스트리밍 렌더링할 수 있도록 설계

#### 서버 렌더링의 작동 방식과 흐름

- 요청 생성

> `renderToPipeableStream` → `createRequestImpl`
>
> - `renderToPipeableStream`: 렌더링할 리액트 엘리먼트 및 옵션 객체를 인수로 전달받음
> - `createRequestImpl`: 요청 객체 생성 → 리액트 엘리먼트, 리소스, 응답 상태, 포맷 콘텍스트 캡슐화

- 작업 시작

> `startWork` → 렌더링 프로세스 시작
>
> - 요청 객체 생성 후 `startWork`를 호출해 렌더링 프로세스 시작
> - 렌더링 프로세스
>   - 렌더링 프로세스는 비동기식이며, Suspense를 사용하여 필요에 따라 중단했다가 다시 시작 가능
>   - 컴포넌트 일시 중단 상태 → 폴백 렌더링 → 작업 완료 → 컴포넌트 재개 → 컴포넌트 렌더링

- 파이프 가능 스트림으로 반환
  - `pipe`: 렌더링된 출력을 Node.js의 HTTP 응답 객체와 같은 [쓰기 가능한 Node.js 스트림](https://nodejs.org/api/stream.html#writable-streams)으로 전달
  - `abort`: [서버 렌더링을 중단](https://ko.react.dev/reference/react-dom/server/renderToPipeableStream#aborting-server-rendering)하고 나머지 작업을 클라이언트 렌더링 모드로 전환
- 목적지로 파이핑 → `pipe`
  - `pipe`를 목적지 스트림과 함께 호출하여 데이터가 전송되기 시작했는지 확인
  - _이미 전송을 시작했다_ → `hasStartedFlowing`을 true로 설정
    - 요청과 목적지를 인수로 `startFlowing` 호출
    - 목적지 스트림의 `drain`, `error`, `close` 이벤트에 대한 핸들러 설정
- 스트림 이벤트 처리 → `drain`, `error`, `close`
  - 목적지 스트림이 더 많은 데이터를 수신할 준비 완료 시
    - `drain` → `startFlowing`을 호출해 데이터 흐름 재개
  - 목적지 스트림에서 오류가 발생하거나 스트림 조기 종료 시
    - `error`, `close` → `abort`를 호출해 렌더링 프로세스 중지
- 렌더링 중단 → `abort`
  - `abort`에 요청 및 렌더링 프로세스를 중단하는 이유 전달하여 서버 렌더링 중단

### `renderToReadableStream`

> 브라우저 스트림을 이용하여 리액트를 그리는 서버 API

#### 함수 시그니처

```tsx
const stream = await renderToReadableStream(reactNode, options?)
```

- 매개변수
  - `reactNode`: HTML로 렌더링하려는 리액트 노드
  - `options?`: 스트리밍 옵션을 지정할 수 있는 객체
- 반환값: Promise 반환

#### 특징

- 브라우저 스트림은 웹 브라우저 내의 클라이언트 환경에서 작동하도록 설계
- 주로 네트워크 요청, 미디어 스트리밍, 브라우저의 데이터 처리 작업에서 스트리밍 데이터 처리
- WHATWG에서 정의한 스트림 표준을 따름 → 프라미스 기반이며 클라이언트 측 작업에 적합

## 언제 무엇을 사용해야 하나요?

### 동기 스트림 기반 방식: `renderToString`

#### 동기 스트림 기반 방식의 문제점

- 비동기식인 네트워크 I/O
  - 우리가 수행하는 모든 데이터 페치: 데이터베이스, 웹 서비스, 파일 시스템 → 대체로 비동기식으로 수행
  - 동기식 → 비동기 요청이 완료될 때까지 기다릴 수 없으며 문자열을 즉시 브라우저로 전송해야 함
  - 서버는 다른 작업을 완료할 수 없고 클라이언트는 셸이라는 껍데기만 받은 채로 시작한 다음에 데이터를 로딩하고 하이드레이션을 한 후, 서버가 멈췄던 지점부터 이어 처리해야 함 → 네트워크 폭포 문제 발생
- 여러 클라이언트에 응답하는 서버
  - 서버와 클라이언트 같은 1:N 관계에서 작업 차단 → 클라이언트가 예상보다 오래 대기해야 한다는 의미

### 비동기 스트림 기반 방식: `renderToPipeableStream`, `renderToReadableStream`

- `renderToPipeableStream`: Node.js 스트림 → 서버 네이티브 방식
- `renderToReadableStream`: 브라우저 스트림 → 브라우저 네이티브 방식

#### 비동기 스트림 기반 방식의 장점

- 스트리밍
  - 서버는 전체 페이지가 렌더링되기 전에 HTML을 클라이언트에 전송 가능 → 사용자 경험 개선, 성능 향상
- 유연성
  - HTML이 렌더링되는 방식을 더 세밀하게 제어 가능
  - 렌더링 파이프라인을 목적에 맞게 조정 가능 → 효율적인 서버 사이드 렌더링 솔루션 가능
- Suspense 지원
  - 서버 사이드 렌더링 하는 동안 비동기 데이터 페치와 지연 로딩을 보다 효과적으로 관리 가능
  - 필요한 데이터가 준비되었을 때만이 해당 데이터에 의존하는 컴포넌트를 렌더링 가능

> [!WARNING]
>
> #### 현재 사용중인 많은 서드 파티 라이브러리가 호환되지 않을 수 있습니다
>
> - 데이터 페치, CSS 관련 라이브러리 등 많은 서드 파티 라이브러리가 개념적으로 서버에서 완전히 실행이 끝나야 데이터를 생성하고, 그 데이터를 사용해 애플리케이션을 다시 렌더링해야 실제로 서버에서 스트리밍할 수 있기 때문
> - 서버에서 렌더링이 완료되지 않은 채 브라우저에서 부분적으로 하이드레이션을 시작해야 하는 케이스를 지원하지 않음
> - 리액트 v19에서 `prefetchDNS`, `preconnect`, `preload` 등 새로운 API를 추가하여 더 효율적인 서버 렌더링을 지원하고 있지만 아직은 부족한 상태

## 직접 구현하지 마세요

> _그냥 프레임워크를 사용하라_ 😂

#### 에지 케이스 및 복잡성 처리

- 복잡한 문제와 다양한 에지 케이스
  - 복잡한 문제와 다양한 에지 케이스에 대한 해결책이 대거 포함된 상태 → 복잡성을 직접 처리할 필요 없음
- 보안 등의 자체적으로 구현하면 인적 오류의 위험이 발생할 수 있는 문제
  - 민감한 데이터의 올바른 처리 보장 + 안전하고 격리된 데이터 페치 방식을 사용
  - 데이터 유출 가능성을 사전에 방지

#### 성능 최적화

- 자동 코드 분할, 서버 렌더링, 캐싱 등의 성능 최적화 기능 제공

#### 개발자 경험 및 생산성

- 기본 서버 렌더링 인프라를 걱정하지 않고 애플리케이션 기능 구현에 집중 가능
- 생산성 향상 및 DX 개선

#### 모범 사례와 코딩 규칙

- 프레임워크에서 제안하는 코딩 규칙을 따르면 탄탄한 기반에서 애플리케이션 작성 가능

> 프레임워크를 활용함으로써 개발 시간을 절약하고, 모범 사례를 준수하며, 각 프레임워크 커뮤니티에서 제공하는 지속적인 개선과 지원 혜택을 누릴 수 있습니다.
