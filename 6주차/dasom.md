# 6장 서버 사이드 리액트

2025.03.23 dasom

## 6.1 클라이언트 사이드 렌더링 한계

**1. 검색 엔진 최적화 (SEO)**
일부 검색 엔진의 크롤러는 자바스크립트를 실행하지 않으며, 실행하더라도 예상대로 실행되지 않을 수 있다.

**2. 성능**
네트워크 환경이나 기기의 성능에 따라 문제를 겪을 수 있다. (리액트18을 기준으로 리액트와 리액트 돔의 번들 크기는 각 6.4KB와 130.2KB 이다.)
클라이언트 전용 애플리케이션은 네트워크 폭포라는, 자바스크립트 때문에 초기 페이지 로드가 차단되는 현상이 발생한다.

**3. 보안**
크로스 사이트 요청 위조(CSRF) 공격에 취약하다.
클라이언트와 서버가 서로를 알지 못하는 상황이 발생해, 악성 공격에 취약하다.


## 6.2 서버 렌더링의 부상

**1. 최초 의미 있는 페인트가 완성되는 시간이 더 빨라진다.**

**2. 웹 애플리케이션의 접근성을 개선한다.**

**3. 웹 애플리케이션의 SEO를 개선할 수 있다.**

**웹 애플리케이션의 보안도 향상시킬 수 있다.**

단, 서버에서 렌더링된 HTML은 정적이며 자바스크립트를 읽어들이지 않은 상태라, 상호 작용 지원이 부족하다.
따라서 필요한 자바스크립트를 정적 HTML에 공급해주는 하이드레이션이 필요하다.


## 6.3 하이드레이션
하이드레이션: 정적 HTML에 이벤트 리스너와 여러 자바스크립트 기능을 추가하는 프로세스
목적: 사용자에게 빠르고 원활한 경험 제공

하이드레이션 단계
* 클라이언트 번들 로딩 -> 이벤트 리스너 추가

리액트는 하이드레이션을 하면서 정적 HTML의 돔 구조와 리액트가 정의한 돔 구조가 일치시켜 이벤트 리스너를 등록함. 따라서 일치하지 못하다면 애플리케이션이 예상대로 동작하지 않을 수 있게 됨.

하이드레이션에 대한 비판
* 서버에서 리액트 애플리케이션을 렌더링한 후 다시 클라이언트 번들을 바운로드하고 이벤트 리스너를 추가한 후 '리렌더링'해야 해 사용자에게 표시되는 지점과 사용자가 실제로 사이트를 사용할 수 있는 시점 사이에 지연이 발생할 수 음
* 재개 가능성을 활용해 인터랙티브 시간을 짧아지게 할 수 있지만, 구현에 따르는 복잡성을 감수할 가치가 있는지는 여전히 논란.


## 6.4 서버 렌더링 작성
기존 리액트 앱에 서버 렌더링을 추가하기 위해서는 Next.js나 Remix 같은 서버 렌더링 프레임워크를 사용해서 구현할 수 있다.
수동으로 추가하고 싶다면 (교육용으로만...) 프로젝트 루트에 serve.js 파일을 만들어 구현 가능


## 6.5 리액트의 서버 렌더링 API

### ReactDOMServer.renderToString()
* 서버에서 리액트 컴포넌트를 HTML 문자열로 렌더링할 때 사용
* 동기식으로 동작 -> 실행이 중단되거나 일시적으로 중지될 수 없어, 컴포넌트가 루트에서 깊이 떨어져있다면 시간이 걸릴 수 있음.
* 또한 완전히 렌더링된 HTML을 반환하므로 대규모 애플리케이션에서는 메모리 사용량이 과도할 수 있음 -> 서버 과부하 혹은 서버 프로세스 중단 위험
* 스트리밍을 지원하지 않아 클라이언트로 전송하려면 HTML 문자열 전체를 생성해야 함. 따라서 문자열 전체가 생성될 때까지 대기한 후에 클라이언트가 콘텐츠를 표시할 수 있음


### ReactDOMServer.renderToPipeableStream()
* 리액트 18에서 도입된 서버 사이드 렌더링 API
* 대규모 리액트 애플리케이션을 Node.js 스트림에 렌더링하는 효율적이고 유연한 방법
* 응답 객체로 파이프할 수 있는 스트림을 반환하며, HTML이 렌더링되는 방식을 세밀하게 제어할 수 있어 다른 Node.js 스트림과 통합할 수 있음

> 스트림이란?
> Node.js에서 스트림은 데이터의 **흐름(데이터를 한 번에 다 처리하지 않고, 조각조각 나눠서 처리)**을 의미

> 파이프란?
> “파이프”는 하나의 스트림에서 나온 데이터를 다른 스트림으로 연결하는 것.
> Node.js에서는 readableStream.pipe(writableStream) 형식으로 사용
```js
//예시
const fs = require("fs");

// 파일을 읽어서 다른 파일로 바로 쓰기 (스트림 간 파이프)
fs.createReadStream("input.txt").pipe(fs.createWriteStream("output.txt"));
```

> 그렇다면 파이프 가능하다는 것은?
> ReactDOMServer.renderToPipeableStream()은 HTML을 스트림으로 생성해주고, 그 스트림을 **응답 객체(res)**로 “파이프”할 수 있다는 의미.
> 즉, 렌더링 결과를 한 번에 다 만들어서 보내는 게 아니라, 조금씩 만들어지는 HTML 조각을 클라이언트에게 지속적으로 전송할 수 있음

> Node.js의 다른 스트림 예시
> fs.createReadStream(), fs.createWriteStream() 파일에 읽고 쓰는 스트림, process.stdin과 같은 터미널 입력 스트림 등
> Node.js 스트림은 데이터가 흐르며 과정에서 데이터를 변환하거나 처리하는 작업이 적용되는데, 데이터 흐름의 특성과 방향에 따라 읽기 가능, 쓰기 가능, 양방향, 변환 스트림으로 분류됨

* 이를 통해 첫 번째 바이트 시간(TTFB) 지표가 향상되고 성능이 개선됨


### 스트림
앞서 다룬 API는 Node.js 스트림을 사용. 브라우저도 스트림을 지원하는데, Node.js스트림과는 약간 상이함.

**Node.js 스트림**
* 파일 입출력, 네트워크 입출력, 종단간 스트리밍을 다루는 서버 환경에서 작동하도록 설계
* Node.js에 맞춰 작성된 API를 따르며 Node.js의 코어로 기능해옴
* 읽기 가능, 쓰기 가능, 양방향, 변환 스트림 각각에 대한 개발 클래스가 있으며 data, end, erro 같은 이벤트를 활용해 스트림의 흐름을 관리하고 데이터를 처리함

**브라우저 스트림**
* 웹 브라우저 내 클라이언트 환경에서 작동하도록 설계
* 네트워크 요청, 미디어 스트리밍, 브라우저의 데이터 처리 작업에서 스트리밍 데이터 처리
* 웹 전체의 API 표준화를 목표로하는 WHATWG(웹 하이퍼텍스트 애플리케이션 테크놀로지 워킹 그룹)에서 정의한 표준 스트림을 따름.
* Node.js 스트림과 달리 read(), write(), pipeThrough() 등의 메서드를 사용해 스트림의 흐름을 제어하고 데이터를 처리함.


### ReactDOMServer.renderToReadableStream()
* renderToPipeableStream과 유사하지만 브라우저에서 읽을 수 있는 스트림을 반환


### 언제 무엇을 사용해야 하나요?
renderToString은 동기식으로 동작해 적합하지 않을 수 있음.
따라서 renderTo*Stream 방식이 더 적합할 수 있겠으나, 사실 그냥 프레임워크를 사용하는 것이 더 권장됨








