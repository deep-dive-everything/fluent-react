# 8장 프레임워크

2025.04.06 dasom

## 8.1 프레임워크가 필요한 이유

 리액트는 높은 유연성을 제공하는 대신 아키텍처를 강제하지 않아 데이터 페치, 서버 사이드 렌더링 등 일반적인 문제에 대한 개발자의 부담이 커지기도 합니다.

 프레임워크는 미리 정의된 구조와 일반적 문제에 대한 해결책을 제시하므로, 개발자는 프레임워크를 활용해 애플리케이션 고유한 기능 개발에만 집중할 수 있습니다.



* 리액트 앱 코드 참고






## 8.2 프레임워크 사용 시 장점

* 구조와 일관성
* 모범 사례의 제공
* 추상화
  * 일반적 작업을 처리하기 위해 더 높은 수준의 추상화를 제공합니다. 코드가 더 깔끔하고 유지보수성이 좋아집니다.
* 성능 최적화
  * 다양한 프레임워크는 코드 분할, 서버 사이드 렌더링, 정적 사이트 생성 등의 최적화 기능이 기본적으로 제공됩니다.
* 커뮤니티와 생태계



## 8.3 프레임워크 사용 시 트레이드 오프

* 학습 곡선
* 유연성과 규칙
  * 강제적인 구조와 규칙은 장점이 될 수도 있지만 제약이 될 수도 있습니다. 프레임워크의 모델에 맞지 않는 고유한 요구사항이 있는 경우 오히려 제약처럼 다가올 것입니다. 또는 빠른 인터넷과 최신 브라우저를 사용하는 특정 사용자 집단을 위해 개발하는 경우에는 서버 사이드 렌더링이나 데이터 페치가 오히려 과한 기능일 수 있습니다.
* 의존과 서약
  * 프레임워크가 유지보수를 중단하거나 사용자의 요구와 다른 방향으로 가는 경우, 많은 비용을 감수하고 다른 프레임워크로의 마이그레이션 혹은 해당 상태에서 직접 유지보수 중 선택해야 합니다.
* 추상화 오버헤드
  * 개발을 단순하게 만들어주지만 동시에 내부에서 일어나는 일을 이해하기 어려워 디버깅과 성능 튜닝에 어려움을 겪을 수 있습니다. 또한 추상화는 약간의 오버헤드를 수반하기 때문에 선응에 영향을 미치기도 합니다.



## 8.4 인기 있는 리액트 프레임워크

### 8.4.1 Remix

>  Remix 설치 에러 해결
>
> 1. `npm install -g create-remix`
> 2. `npm install -g fs-extra`
> 3. `create-remix <folderName>`

### 8.4.2 Next.js



## 8.5 프레임워크 선택

### 8.5.1 프로젝트 요구 사항 이해

* 프로젝트의 규모는 어떻게 되나요?
* 프로젝트에 포함시키고 싶은 주요 기능과 특징은 무엇인가요?
* 서버 사이드 렌더링, 정적 사이트 생성 또는 이 둘의 조합이 필요한가요?
* 블로그나 이커머스 사이트처럼 우수한 SEO가 큰 장점인 콘텐츠 중심 사이트를 만드는 중인가요?
* 실시간 데이터나 매우 동적인 콘텐츠가 애플리케이션의 중요한 부분인가요?
* 빌드 프로세스에 대한 커스터마이징과 제어가 어느 정도로 유연해야 하나요?
* 애플리케이션의 성능과 속도가 얼마나 중요한가요?
* 리액트와 일반적인 웹 개발 개념은 얼만큼 숙지했나요?
* 대상 사용자는 누구인가요?



### 8.5.2 Next.js

* 학습 곡선: 학습 강도가 다소 높을 수 있습니다.
* 유연성: 정적 콘텐츠와 서버 콘텐츠 간의 유연한 전환이 가능합니다.
* 성능: 성능을 매우 중시합니다.



### 8.5.3 Remix

* 학습 곡선: 웹의 기본 기능을 더 많이 사용해 상대적으로 쉽게 배울 수 있습니다.
* 직관성:  프레임워크의 복잡성에 방해받지 않게 하지만 프레임워크의 '마법' 같은 기능은 상대적으로 약할 수 있습니다.
* 성능: 역시 효율과 성능을 중시합니다.



### 8.5.4 트레이드오프

* 라우팅은 어떻게 구현할 것인가?
* 정적 자산(이미지, JS/CSS 파일 등)은 어디에 둘 것인가?
* 서버 렌더링을 해야 하는가?
* 데이터 페치는 어디서 실행해야 하는가?

대부분의 프레임워크는 위의 질문에 대한 답을 제시합니다. 하지만 이때문에 개발자에게 결정권과 제어권이 사라지는 것은 어쩔 수 없습니다.



### 8.5.5 개발자 경험

두 프레임워크 모두 생산성과 사용자 편의성에 중점을 둔 최고 수준의 개발자 경험을 제공합니다. 

빌드 성능을 개선하기 위해 각 프레임워크는 다음과 같은 방식을 취합니다.

Next.js는 정적 생성을 사용해, 빌드시 페이지가 미리 렌더링 됩니다. 덕분에 페이지 로드가 빠르지만 수가 많다면 빌드 시간이 길어질 수 있습니다. 따라서 증분 정적 재생성(개발자가 정적 페이지를 빌드한 후 전체 재빌드 없이도 정적 페이지를 재생성할 수 있는 방식)을 도입했습니다.

Remix는 서버 우선 아키텍처를 선택해 서버에서 필요할 때마다 페이지를 렌더링하고, HTML을 클라이언트로 전송합니다.





### 8.5.6 런타임 성능

Next.js

* 자동 코드 분할 지원, 내장된 Image 컴포넌트는 이미지 로딩 최적화
* 하이브리드 SSG/SSR 모델을 통해 페이지에 최적화된 데이터 페치 전략 선택 가능
* 데이터가 필요하지 않은 페이지에 대해 자동 정적 최적화를 수행해, TTFB(첫 번째 바이트 시간)이 빠름
* 리액트 서버 컴포넌트를 최대한 활용해 클라이언트로 전달되는 자바스크립트의 양을 줄임



Remix

* 페이지를 미리 렌더링하지 않고, 서버 렌더링을 사용해 필요한 HTML만 클라이언트로 스트리밍해 전송함. 동적 콘텐츠의 경우 TTFB가 더 빠를 수 있음
* 캐싱 전략을 개발자가 직접 선택 가능, 페이지의 로딩이 빨라지고 애플리케이션의 안정성 향상

