# 4장 가상 DOM

2025.03.02 dasom

## 4.1 재조정 이해하기

* 재조정: 가상 DOM을 반영하는 것
* 최소한의 DOM API만 호출에 브라우저에 반영하기 위해 변경 사항을 단 한 번의 실제 DOM 업데이트로 처리하는 "일괄 처리"를 수행함



## 4.2 일괄 처리

* 문서 조각
  * 다수의 DOM 노드를 포함하는 컨테이너로, 임시 스테이징 영역처럼 동작함.
  * 따라서 실제 DOM에 영향을 주지 않고 여러 변경 사항을 반영함.
  * 최종적으로 문서조각을 DOM에 추가하면 단 한 번의 리플로와 리페인팅이 발생함. 

* 일괄 처리
  * 재조정 과정에서 문서조각처럼 여러 가상의 DOM 업데이트를 모아 한 번의 DOM 업데이트로 결합하여, 실제 DOM에 대한 업데이트를 "일괄 처리"함
  * e.g. 한 함수에 setCount가 3번 일어났다고 해도, 최종적으로는 결과값에 대해서 "한 번만" 업데이트 함.



## 4.3 기존 기술

예전 리액트(리액트 16 이전)는 렌더링에 스택 데이터 구조를 사용

### 4.3.1 스택 재조정자

* 스택: 선형 구조, LIFO(Last In First Out)
* 순차적으로 변경을 수행해 계산 비용이 비싼 컴포넌트가 렌더링을 막라버리면 (점유해버리면) 사용자 입력이 되지 않거나 버벅거리는 문제가 발생함
* 업데이트의 우선순위가 없어 우선순위가 높은 렌더링 작업이 있어도 현재 진행 중인 렌더링 작업을 멈출 수 없음
* 따라서 토스트 알림 창 같은 불필요한 업데이트가 사용자 상호 작용을 방해하면서 수행되는 경우도 발생



> 추가 예시 by ChatGPT

```js
const ExpensiveComponent = () => {
  // 엄청나게 연산량이 많은 계산을 수행
  let total = 0;
  for (let i = 0; i < 10_000_000_000; i++) {
    total += i;
  }
  return <p>계산 결과: {total}</p>;
};

const App = () => {
  const [count, setCount] = React.useState(0);

  return (
    <div>
      <button onClick={() => setCount((c) => c + 1)}>클릭</button>
      {count % 2 === 0 && <ExpensiveComponent />}
    </div>
  );
};

/**
👉 버튼을 클릭하면 UI가 멈춘다!
	•	ExpensiveComponent가 렌더링될 때 CPU 연산이 너무 많아서, React가 다른 UI 업데이트(예: 버튼 클릭 이벤트 처리)를 할 시간이 없음
	•	결과적으로 사용자가 버튼을 눌러도 반응이 늦어지고, 화면이 한참 후에야 업데이트됨
*/
```

> 추가 정보 by ChatGPT
>
> 해당 방식은 재귀 호출 방식으로 되어 있어, 리액트가 너무 깊은 컴포넌트 트리를 렌더링하면, **재귀 호출이 너무 깊어져 스택 오버플로우가 발생할 가능성 역시 있었음**



## 4.4 파이버 재조정자

* 파이버: 파이버 재조정자를 위한 작업 단위
  * 리액트 엘리먼트에서 생성되는데, 임시적이고 상태가 없는 리액트 엘리먼트와 달리 파이버는 상태를 저장하고 수명이 김
  * 마크 에릭슨: 파이버는 특정 시점에 존재하는 실제 컴포넌트 트리를 나타내는 리액트의 내부 데이터 구조다.

### 4.4.1 데이터 구조로서의 파이버

* 파이버 데이터 구조: 리액트 애플리케이션에서 컴포넌트 인스턴스와 그 상태를 표현
  * 변경 가능한 인스턴스로 설계되어 조정과정에서 필요에 따라 업데이트 되고 재배치 됨.
* 파이버 노드
  * tag: 각 컴포넌트 유형에는 고유한 숫자 ID가 파이버로 성정
  * type: 함수 또는 클래스 컴포넌트
  * props: 컴포넌트에 대한 입력 프롭 또는 함수에 대한 입력 인수
  * stateNode: 컴포넌트의 인스턴스. 이를 사용해 트리를 순회함

* 조정 과정 
  * 파이버 노드가 생성 - 파이버 재조정자는 작업 루트를 사용해 사용자 인터페이스 업데이트 (업데이트가 필요한 경우 파이버 노드를 '더티'로 표시) - 새 DOM 트리를 메모리에 생성 



### 4.4.2 더블 버퍼링

* 더블 버퍼링: 이미지나 프레임을 저장하기 위한 두 개의 버퍼를 생성하고 일정한 간격으로 두 버퍼를 전환해 최종 이미지나 동영상을 표시 (다음 화면을 화면 밖에서 준비한 다음 현재 화면으로 보내는 것)
* 최초의 상태 반영 업데이트 (렌더링) - 파이버 트리와 교체 (재조정의 커밋 단계 또는 커밋)
* 이를 바탕으로 우선순위가 더 높은 새로운 업데이트만을 반영 가능 (필요 없는 경우를 버릴 수 있음)



### 4.4.3 파이버 재조정

**렌더링 단계**

* beginWork

  업데이트 필요 여부를 다타내는 플래그를 설정 (렌더링 단계의 시작)

  여러 플래그를 설정하고 다음 파이머 노드로 이동하며 트리 순회 -> 완료되면 파이버 노드에서 completeWork를 호출하고 다시 거슬러 올라가며 순회

  * beginWork의 시그니처
    * current: 업데이트 중인 작업용 노드에 해당하는 트리의 파이버 노드에 대한 참조, 불변하는 값, 비교용으로만 사용
    * workInProgress: 업데이트 중인 파이버 노드
    * renderLanes: 업데이트가 처리되는 '레인'을 나타내는 비트마스크. 우선순위가 더 높을수록 더 높은 레인이 할당 (== 우선순위 지정 및 리액트 동시성 관리 지원)

* completeWork

  작업용 파이버 노드에 업데이트를 적용하고 애플리케이션의 업데이트된 상태를 나타내는 실제 DOM트리를 새롭게 생성

  

**커밋 단계**

* 변형 단계

  렌더링 단계에서 가상 DOM에 적용된 변경 사항을 실제 DOM에 반영

  특후 함수를 호출해 더이상 필요하지 않은 노드를 제거하기도 함

* 레이아웃 단계

  DOM에서 업데이트된 노드의 새 레이아웃을 계산 -> 실제 DOM에 반영 완료

* 커밋 단계에서 발생하는 효과

  * 배치 효과: 새 컴포넌트가 DOM에 추가될 때 발생
  * 업데이트 효과: 컴포넌트가 새로운 프롭이나 상태로 업데이트 될 때 발생
  * 삭제 효과: 컴포넌트가 DOM에서 제거될 때 발생
  * 레이아웃 효과: 브러우저의 페인트 가능 시점 전에 발생하여 페이지 레이아웃을 업데이트하는 데 사용
  * 그 외: 패시브 효과는 브라우저의 페인트 가능 시점 후에 실행되도록 예약된 사용자 정의 효과 (useEffect 훅을 사용해 관리됨) <- 렌더링 단계에서 수행되지 않아 초기 렌더링에 중요하지 않은 작업 수행 시 유용 

**화면에 모두 표시하기**

​	FiberRootNode 는 재조정 과정의 커밋단계를 관리하는 핵심 데이터 구조

​	렌더링 프로세스가 완료되면 리액트는 comitRoot 함수를 호출해 작업용 트리에 적용된 변경사항을 실제 DOM에 커밋하고, commitRoot는 FiberRootNode의 포인터를 현재 트리에서 작업용 트리로 전환하고, 작업용 트리를 새로운 현재 트리로 만듦.
