# 4장 재조정

## 4.1 재조정 이해하기
- 리액트는 재조정이라는 프로세스를 통해 가상 DOM을 현실로 만듭니다.
- 우리가 JSX로 작성한 코드는 React.createElement 함수를 통해 리액트 엘리먼트를 생성해주고 아래와 같은 형태로 가상 DOM을 만듭니다.
```text
{
    type: 'main',
    props: {
        children: [
            {
                type: 'h1',
                props: {
                    children: 'Hello, World!'
                }
            }
        ]
    }
}
```
- 첫번째 렌더링이므로 이 트리는 꼭 필요한 최소한의 DOM API만 호출해 브라우저에 반영됩니다.

## 4.2 일괄 처리
- 리액트는 여러 가상 DOM 업데이트를 모아 한 번의 DOM 업데이트로 결합한 후 실제 DOM에 대한 업데이트를 일괄 처리합니다.
- setCount(prev => prev+1)를 세번 호출한다고 하더라도 가상 DOM을 통해 실제 DOM을 업데이트하는 횟수는 한 번입니다.

## 4.3 기존 기술
### 4.3.1 스택 재조정자
- 예전 리액트는 렌더링에 스택 데이터 구조를 사용했습니다.
- 스택 재조정자는 간단한 경우에는 잘 작동했지만, 애플리케이션 규모가 커지고 복잡해지면서 여러가지 문제가 발생했습니다.
- 필수적이지 않고 비싼 연산을 하는 컴포넌트가 다른 컴포넌트를 렌더링하기 전에 시작되면 사용자의 입력을 처리하는데 지연이 발생할 수 있습니다.
    - 이러한 렌더링은 중단하거나 취소할 수도 없었습니다.
- 따라서 우선순위에 따라 렌더링의 우선순위를 정하는 것이 필요했고 리액트 팀은 이를 해결하기 위해 Fiber 재조정자를 개발했습니다.

## 4.4 파이버 재조정자
- 파이버 재조정자에는 조정자를 위한 작업 단위를 나타내는 파이버라는 데이터 구조가 사용됩니다.
    - 이는 리액트 엘리먼트에서 생성되는데 파이버는 상태를 저장하고 수명이 긴 반면 리액트 엘리먼트는 임시적이고 상태가 없다는 차이가 있습니다.
- 리액트는 재조정에 파이버 트리를 사용합니다.

### 4.4.1 데이터 구조로서의 파이버
- 파이버 데이터 구조는 리액트 애플리케이션에서 컴포넌트 인스턴스와 그 상태 표현
- 변경 가능한 인스턴스로 설계되었으며 조정 과정에서 필요에 따라 업데이트되고 재배치됨
- 파이버 노드의 각 인스턴스에는 해당 컴포넌트에 대한 정보, 다시 말해 프롭, 상태, 하위 컴포넌트, 컴포넌트 트리에서의 위치 정보, 파이버 재조정자가 업데이트 우선순위를 정하는 데 사용하는 메타데이터 들어있음

```text
{
    tag: 3, // 3 = 클래스 컴포넌트
    type: App,
    key: null,
    ref: null,
    props: {
        name: "Tejas",
        age: 30,
        },
    stateNode: AppInstance,
    return: FiberParent,
    child: FiberChild,
    sibling: FiberSibling,
    index: 0,
    // ...    
}
```

- 파이버 노드 구성요소
  - tag: 각 컴포넌트 유형
  - type: App은 이 파이버가 나타내는 함수 컴포넌트 또는 클래스 컴포넌트
  - props: 컴포넌트에 대한 입력 프롬 또는 함수에 대한 입력 인수
  - stateNode: 이 파이버가 나타내는 APP 컴포넌트의 인스턴스. 컴포넌트 트리에서의 위치는 return, child, sibling, index 속성을 통해 알 수 있음
- 파이버 재조정에는 현재 파이버 트리와 다음 파이버 트리를 비교해 어느 노드를 업데이트,추가,제거할지 파악하는 작업이 포함됨
- createFiberFromTypesAndProps라는 함수로 가상 DOM의 각 리액트 엘리먼ㄴ트에 대해 파이버 노드 생성
- 파이버 노드가 생성되면 파이버 재조정자는 작업 루프를 사용해 사용자 인터페이스를 업데이트함
- 작업 루프는 루트 파이버 노드에서 시작해 컴포넌트 트리를 따라 내려가면서 업데이트가 필요한 경우 각 파이버 노드를 '더티'로 표시 (beginWork)
- 끝에 도달하면 다시 반대로 순회하면서 브라우저의 DOM 트리와는 분리된 새 DOM 트리를 메모리에 생성 (completeWork)
- 새 DOM 트리는 이후 화면에 반영됨
- 사용자가 볼 수 없는 오프스크린 렌더링 프로세스
- 다음 화면을 화면 밖에서 준비한 다음 현재 화면으로 내보내는 더블 버퍼링 방식 사용

### 4.4.2 더블 버퍼링
- 이미지나 프레임을 저장하기 위한 두개의 버퍼를 생성하고 일정한 간격으로 두 버퍼를 전환해 최종 이미지나 동영상 표시
1. 첫 번째 버퍼가 초기 이미지나 프레임으로 채워짐
2. 첫 번째 버퍼가 표시되는 동안 두 번째 버퍼가 새 데이터나 이미지로 업데이트 됨
3. 두 번째 버퍼가 준비되면 첫 번째 버퍼로 전환되어 화면에 표시됨
4. 첫 번째와 두 번째가 일정한 간격으로 전환되어 최종 이미지나 동영상을 표시하는 프로세스가 계속 됨

- 파이버 재조정도 비슷
  - 업데이트가 발생하면 현재 파이버 트리가 포크되어 주어진 사용자 인터페이스의 새로운 상태를 반영하도록 업데이트 됨 (렌더링)
  - 현재 트리를 대체할 트리가 준비되고 현재 파이버 트리와 교체됨 (커밋)

### 4.4.3 파이버 재조정
- 파이버 재조정은 렌더링과 커밋 두 단계로 나뉨
- 리액트는 렌더링 작업을 수행하고 이를 DOM에 커밋해서 사용자에게 보여주기 전에 언제든 폐기할 수 있게 되었음(렌더링 중단)
- 렌더링이 중단 가능한 듯 보이는 이유는 리액트 스케줄러가 5밀리초마다 실행을 메인 스레드로 돌려주기 때문

**렌더링 단계**
- 렌더링 단계는 현재 트리에서 상태 변경 이벤트가 발생하면 시작
- 각 파이버를 재귀적 단계적으로 순회하고 업데이트가 보류 중이라는 신호 플래그를 설정해 대체 트리에 오프스크린 변경 작업을 수행

beginWork(작업 시작)
- beginWork는 작업용 트리에 있는 파이버 노드의 업데이트 필요 여부를 나타내는 플래그를 설정
- beginWork의 시그니처
```js
function beginWork(
    current: Fiber | null,
    workInProgress: Fiber,
    renderLanes: Lanes
): Fiber | null
```

- current
  - 업데이트 중인 작업용 노드에 해당하는 현재 트리의 파이버 노드에 대한 참조
  - 트리의 이전 버전과 새 버전 간에 변경된 사항과 업데이트할 사항을 결정하는 데 사용
  - 불변하는 값이며 비교용으로만 사용됨
- workInProgress
  - 작업용 트리에서 업데이트 중인 파이버 노드 
  - beginWork 함수에 의해 업데이트 되어 '더티'로 표시된채 반환됨
- renderLanes
  - 업데이트가 처리되는 레인을 나타내는 비트마스크
  - 리액트 컴포넌트를 변경하면 우선순위를 비롯한 여러 특성에 따라 레인이 할당되고 변경의 우선순위가 높을수록 더 높은 레인이 할당됨
  - 렌더링 단계가 마무리되면 getLanesToRetrySynchronouslyOnError 함수를 호출해 레인을 재시도하고 렌더링을 다시 시작

completeWork(작업 완료)
- completeWork 함수는 작업용 파이버 노드에 업데이트를 적용하고 애플리케이션의 업데이트된 상태를 나타내는 실제 DOM 트리를 새롭게 생성
- 이 작업을 통해 DOM에서 분린된 트리를 브라우저가 시각적으로 표현하는 영역 바깥에 구성
- 호스트 환경이 브라우저라면 document.createElement 또는 newElement.appendChild 같은 작업 수행
- 이때 만약 우선순위가 더 높은 업데이트가 예약되면 여기서 만들어진 UI는 버려질 수 있음

```js
function completeWork(
    current: Fiber | null,
    workInProgress: Fiber,
    renderLanes: Lanes
): Fiber | null
```

- completeWork가 트리 맨 위에 도달해 새 DOM 트리를 구성하면 렌더링 단계가 완료되었다고 보고 리액트는 커밋 단계로 넘어감

**커밋 단계**
- 커밋 단계는 렌더링 단계에서 가상 DOM에 적용된 변경 사항을 실제 DOM에 반영
- 새 가상 DOM 트리가 호스트 환경에 커밋되고 작업용 트리가 현재 트리로 바뀜

1. 변형 단계
- 변형 단계는 커밋 단계의 첫 부분으로 가상 DOM에 적용된 변경 사항을 실제 DOM에 반영
- 이 단계에서 리액트는 적용할 업데이트를 식별하고 commitMutationEffects라는 특수 함수 호출

```js
function commitMutationEffects(Fiber){
    switch(Fiber.tag){
        case HostComponent:
            // 새로운 프롭과 자식을 사용한 DOM 노드 업데이트
            break;
        case HostText:
            // DOM 노드의 텍스트 콘텐츠 업데이트
            break;
      case ClassComponent:
            // componentDidMount, componentDidUpdate, componentWillUnmount 같은 수명 주기 메서드 호출
            break;
        // ...
    }
}
```

2. 레이아웃 단계
- 레이아웃 단계는 커밋 단계의 둘째 부분으로 DOM에서 업데이트 된 노드의 새 레이아웃을 계산합니다.
- 이 단계에서 리액트는 commintLayoutEffects라는 특수 함수를 호출하여 DOM에서 업데이트된 노드의 새 레이아웃을 계산합니다.
- 레이아웃 단계가 완료되면 리액트는 렌더링 단게에서 가상 DOM에 적용되었던 변경 사항을 실제 DOM에 성공적으로 반영하게 됩니다.

**효과**
- 커밋 단계에서는 여러 부작용이 특정 순서로 실행되며 그 순서는 효과 종류에 따라 달라질 수 있습니다.
- 배치효과
  - 새 컴포넌트가 DOM에 추가될 때 발생
- 업데이트 효과
  - 컴포넌트가 새로운 프롭이나 상태로 업데이트될 때 발생
- 삭제 효과
  - 컴포넌트가 DOM에서 제거될 때 발생
- 레이아웃 효과
  - 브라우저의 페인트 가능 시점 전에 발생하며 페이지 레이아웃을 업데이트하는 데 사용
  - 함수 컴포넌트에서는 useLayoutEffect 훅을 클래스 컴포넌트에서는 componuntDidUpdate 메서드를 사용
- 패시브 효과
  - 브라우저의 페인트 가능 시점후에 실행되도록 예약된 사용자 정의 효과 useEffect 훅을 사용해 관리됨

**화면에 모두 표시하기**
- 리액트는 current 트리나 workInProgress 트리 중 하나위에 FiberRootNode를 둡니다.
- FiberRootNode는 재조정 과정의 커밋 단계를 관리하는 핵심 데이터 구조입니다.
- 가상 DOM이 업데이트되면 리액트는 현재 트리를 변경하지 않은 채 작업용 트리를 업데이트 합니다.
- 이를 통해 애플리케이션의 현재 상태를 유지하면서 가상 DOM을 계속 렌더링하고 업데이트할 수 있습니다.
- 렌더링 프로세스가 완료되면 리액트는 commitRoot 함수를 호출해 작업용 트리에 적용된 변경 사항을 실제 DOM에 반영합니다.
- commitRoot는 FiberRootNode의 포인터를 현재 트리에서 작업용 트리로 변경하고 실제 DOM에 적용된 변경 사항을 화면에 표시합니다.
