# 1. 가상 DOM 소개

- 가상DOM : HTML문서를 자바스크립트 객체로 모델링 한 것
- 실제 DOM과의 차이점 : 실제 DOM은 노드 객체로 구성되고 가상DOM은 설명 역할을 하는 평범한 JS객체로 구성됨
- 가상 DOM을 업데이트 하는 이유 : 실제 DOM을 업데이트가 다소 느리고 비용이 많이 발생.
- 가상 DOM은 평범한 JS객체로 구성되므로 브라우저나 호스트 환경에 상관 없이 자바스크립트 엔진을 활용하는 다양한 알고리즘에 접근해 빠르고 효율적으로 조작함.
- 가상 DOM이 업데이트 되면 비교 알고리즘으로 이전 버전과 새 버전의 차이점을 식별한 뒤 최소한의 변경사항을 선정해 적용하면서 성능 영향을 최소화

# 2. 실제 DOM

- DOM : 웹 브라우저에서 HTML페이지 구문을 분석해 변환한 객체 모델.
- 트리의 각 노드는 HTML엘리먼트를 나타내며 자바스크립트를 통해 조작할 수 있는 속성과 메서드가 포함되어있음.
- CSS선택자 기반으로 엘리먼트를 선택하는 경우 크고 복잡한 문서로 작업할 때 속도가 느려짐
- Id 선택자 기반으로 엘리먼트를 선택하는 경우 유효성 검사가 필요하지 않고 특정성이 높아 효율적임. 하지만 Id고유성을 강제하지 않아 충돌이 일어난 수 있음.
- DOM은 사용자 상호 작용, 네트워크 요청, 클라이언트 측 스크립트, 가변적 이벤트 등의 요소 떄문에 변동성이 큼.

## 2.1 실제 DOM의 문제점

### 성능

- DOM을 변경할 때마다 브라우저는 레이아웃을 다시 계산하고 페이지의 영향을 받는 부분을 다시 그림
- getBoundingClientRect() : offsetWidth 같은 레이아웃 속성에 접근할 때 발생하는 리플로를 방지할 수 있음
    - 한번의 호출로 여러 레이아웃을 검색해 리플로 발생 횟수가 줄어듬.
    - 읽고 쓰는 작업이 반복될때 발생하는 불필요한 재계산인 레이아웃 스레싱 현상이 최소화됨
    - 레이아웃스레싱이 발생하면 성능저하로 사용자 경험을 악화시킴
- 가상 DOM을 사용하면 실제 DOM의 복잡성을 추상화하고 UI를 더 가볍게 표현하면서 효율적이고 성능이 뛰어난 UI를 제작할 수 있음.
- CPU효율성을 우선시하면 처리능력이나 메모리 관계없이 다양한 기기의 사용자가 접근할 수 있는 애플리케이션 개발이 가능해짐

### 브라우저 간 호환성

- 브라우저마다 문서 모델링 방식이 달라 웹 애플리케이션의 일관성이 보장되지 않고 버그가 발생할 수 있음.
- 특정 DOM 엘리먼트와 속성을 지원하지 않는 브라우저가 있음.
- 리액트의 합성이벤트 시스템
    - 통합 인터페이스 : 기본 이벤트를 둘러싼 래퍼 객체인 SyntheticEvent로 추상화해 이벤트와 상호작용하는 일관된 방법을 제공하여 개발자가 특정 브라우저에 맞춘 개별 코드를 작성하지 않아도 됨.
    - 이벤트 위임 : 이벤트 리스너를 엘리먼트에 직접 추가하지 않고 루트에서 이벤트를 받음. 구형 브라우저의 특정 엘리먼트에서 일부 이벤트를 사용할 수 없는 문제를 방지함.
    - 다양한 기능 개선 : 컴포넌트의 종류마다 다른 이벤트의 동작을 정규화함.
    - 네이티브 이벤트에 접근 : event.nativeEvent를 통해 네이티브 이벤트에도 접근할 수 있음.

## 2.2 문서 조각

- 문서 조각 : DOM노드를 저장하는 가벼운 컨테이너
- 기본 DOM에 영향을 주지 않고 여러가지 업데이트를 수행할 수 있는 임시 저장소처럼 동작
- 업데이트가 완료되면 문서 조각을 DOM에 추가하는 방식으로 리플로와 리페인팅을 한번만 발생
- 일괄 업데이트 : 변경사항을 일괄적으로 처리해 리플로와 리페인팅을 한번만 발생시킴
- 메모리 효율성 : 문서 조각에 추가된 노드는 문서의 실제 DOM에서 제거됨
- 중복 렌더링 방지 : 스타일 재계산과 스크립트 실행의 중복 수행을 방지
- 리액트의 가상DOM과 비교
    - 일괄 업데이트
    - 효율적인 비교 알고리즘
    - 단일 렌더링
- 리액트는 문서 조각과 관련된 복잡한 작업을 개발자가 신경쓰지 않아도 되도록 내부적으로 처리함

# 3. 가상 DOM 작동 방식

- 실제 DOM을 직접 수정하지 않고 가상 표현을 변경할 수 있음.
- 브라우저마다 다양한 실제 DOM구현 차이를 추상화한 일관된 API를 제공해 엘리먼트를 작성하고 업데이트 하는 환경 개선

## 3.1 리액트 엘리먼트

- 리액트 애플리케이션의 가장 작은 구성. 화면에 표시되어야하는 내용 설명
- React.createElement함수를 사용해 생성되며 엘리먼트를 중첩해 복잡한 UI를 만들 수 있음.
- $$typeof : 객체가 유효한 엘리먼트인지 식별하는 심벌
- type
    - 엘리먼트가 나타내는 컴포넌트의 종류
    - 문자열인 경우 HTML 태그, 함수인 경우 JSX를 반환하는 함수
- ref
    - 부모 컴포넌트가 기본 DOM노드에 대한 참조를 요청할때 사용.
    - DOM을 직접 조작할 때
- props : 컴포넌트에 전달된 모든 속성과 프롭을 포함하는 객체
- _owner : 엘리먼트를 생성한 컴포넌트를 추적하기 위해 리액트에서 내부적으로 사용.
- _store : 엘리먼트에 대한 추가 데이터를 저장하기 위해 리액트 내부적으로 사용

## 3.2 가상 DOM과 실제 DOM 비교

- 재조정 프로세스 : 렌더링 되면 리액트는 새 가상 DOM트리를 생성하고 이전 가상 DOM트리와 비교한 뒤 이전 트리를 업데이트하는데 필요한 최소 변경 횟수 계산

## 3.3 효율적인 업데이트

- 디핑 : 새 트리와 이전 트리를 노드별로 비교해 트리의 어느 부분이 변경되었는지 알아내는 작업. 이떄 사용되는 알고리즘이 디핑 알고리즘임
- 불필요한 리랜더링
    - 리액트는 프롭에 변경되지 않는 컴포넌트도 무시하지 않고 상태가 변경된 컴포넌트의 자식 컴포넌트를 모두 호출함
    - 하위 컴포넌트에 불필요한 리렌더링이 광범위하게 발생하지 않도록 관리해야함.
    - 컴포넌트 구조화, memo또는 useMemo 기능 관리
