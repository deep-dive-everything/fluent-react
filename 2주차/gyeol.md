# 3장 - 가상 DOM(Virtual Document Object Model)

## 3.1 가상 DOM의 소개

- DOM과 마찬가지로 HTML 문서를 자바스크립트 객체로 모델링한 것
- 실제 DOM은 노드 객체로 구성되지만, 가상 DOM은 설명 역할을 하는 JS 객체로 구성됨
- 리액트는 개발자가 setState 혹은 다른 메커니즘을 통해 UI 변경을 지시할 때마다 가상 DOM을 업데이트 한 후 변경사항에 맞춰 실제 DOM을 업데이트하는 재조정 과정을 수행험
- 리액트가 가상 DOM을 먼저 업데이트 하는 이유
    - 실제 DOM의 업데이트는 다소 느리고 비용이 많이 들 수 있음(reflow 등)
- 가상 DOM의 장점
    - 가상 DOM 업데이트는 실제 페이지 레이아웃을 변경하지 않으므로 빠르게 동작함
    - 가상 DOM은 평범한 자바스크립트 객체로 구성됨 
    → 브라우저나 다른 호스트 환경과 관계없이 자바스크립트 엔진을 최대한 활용하는 알고리즘에 접근하여 빠르고 효율적인 조작이 가능함

## 3.2 실제 DOM

- DOM(Document Object Model)
    - HTML 문서 구조를 객체로 표현한 것
- 웹 브라우저는 HTML 페이지를 읽어 들인 후 구문을 분석해 노드와 객체의 트리(DOM)으로 변환
- DOM은 자바스크립트 객체. 웹 페이지의 현재 상태를 실시간으로 표현한 것
- 예시
    
    ```html
    <!DOCTYPE html>
    <html>
      <head>
        <style>
          .red  { color: #ff0000; }
          .blue { color: #0000ff; }
        </style>
      </head>
      <body>
        <div>
          <h1>Cities</h1>
          <ul>
            <li id="one" class="red">Seoul</li>
            <li id="two" class="red">London</li>
            <li id="three" class="red">Newyork</li>
            <li id="four">Tokyo</li>
          </ul>
        </div>
      </body>
    </html>
    ```
    
- 위 HTML 문서는 아래의 DOM Tree로 변환됨
    ![image](https://github.com/user-attachments/assets/845d0c24-52d9-4d8d-b4c3-eb72575777e1)
    
    [Live DOM Viewer](https://software.hixie.ch/utilities/js/live-dom-viewer/#)
    
- DOM의 각 노드는 HTML 엘리먼트를 나타내며, 자바스크립트를 통해 조작할 수 있는 속성과 메서드가 포함되어있음
- DOM에서 하나의 엘리먼트 선택하기
    - document.querySelector(cssSelector)
        - CSS 선택자를 사용하여 엘리먼트를 탐색하고 선택자와 일치하는 첫 번째 엘리먼트를 반환
        - CSS 선택자를 기반으로 실제 DOM에서 엘리먼트를 선택하는 강력한 도구
        - 크고 복잡한 문서의 경우 속도가 느려지는 것이 문제 → document.querySelector 호출 시 브라우저가 전체 문서 트리에서 일치하는 엘리먼트를 검색하게됨(문서 상단부터 아래쪽으로 이동하면서 엘리먼트를 탐색). CSS 선택자의 복잡도에 따라 탐색과정이 복잡해지므로 브라우저는 선택자 자체를 먼저 평가해야함
    - document.getElementById(id)
        - 주어진 ID에 해당하는 엘리먼트를 찾는 메서드
        - CSS 선택자와 달리 유효성 검사가 필요하지 않고 특정성이 높아 효율적인 편
- DOM은 다양한 요소에 의해 영향을 받으므로 변동성이 큼(사용자 상호작용, 네트워크 요청, 클라이언트 측 스크립트 등)

### 3.2.1 실제 DOM의 문제점

- 실제 DOM에는 고성능 웹 애플리케이션을 구축하기 어렵게 만드는 문제점이 존재

### 성능

- Reflow와 Repaint
    - 엘리먼트의 추가나 제거, 엘리먼트의 텍스트나 속성 업데이트 등으로 DOM을 직접 변경할 때마다 브라우저는 레이아웃을 다시 계산하고 페이지의 영향을 받는 부분을 다시 그리는 작업을 수행함
    - 크고 복잡한 웹 페이지일 수록 이 과정으로 인해 속도가 느려지고 리소스를 많이 사용하게 됨
- 예시 - DOM 엘리먼트의 offsetWidth 속성을 읽는 경우
    - offsetWidth
        - 엘리먼트의 레이아웃과 상위 엘리먼트에 따라 계산되는 속성(브라우저가 정확한 값을 반환하기 위해 레이아웃 정보가 최신 상태인지 확인이 필요함)
    - **offsetWidth 속성을 읽으면 브라우저가 레이아웃을 다시 계산하여 많은 비용이 발생할 수 있음(Reflow)**
- offsetWidth 같은 레이아웃 속성에 접근 시 발생하는 Reflow를 방지하는 방법
    - **`getBoundingClientRect()` 메서드로 레이아웃 읽기, 쓰기를 일괄처리 하기**
        - getBoundingClientRect는 한 번의 호출로 여러 레이아웃 속성을 검색하므로 Reflow 발생 횟수를 줄일 수 있음
        - 읽기와 쓰기 작업을 종류 별로 나눠 일괄처리하면 레이아웃 스래싱 현상이 최소화됨
        - 코드
            
            ```jsx
            // 성능이 더 좋은 방식으로 레이아웃 속성에 접근
            function getOffsetWidthoutTriggeringReflow(element) {
            	let width;
            	// 읽기 작업을 일괄 처리
            	const rect = element.getBoundingClientRect();
            	width = rect.width;
            	// 다른 읽기 작업 실행
            	// 이후 필요한 경우 쓰기 작업 실행
            	return width;
            }
            
            const element = document.querySelector(".myElement");
            const width = getOffsetWidthoutTriggeringReflow(element);
            console.log(width);
            ```
            
    - 레이아웃 스래싱
        - 레이아웃 속성을 읽고 쓰는 작업이 자주 반복될 때 발생하는 불필요한 레이아웃 재계산을 의미
        - 웹 페이지의 성능을 크게 저하시켜 사용자 경험을 악화시킴
    - 하지만 대기 중인 레이아웃 변경 사항이 있을 경우 `getBoundingClientRect()` 도 Reflow를 발생 시킬 수 있음
- DOM의 성능 문제는 CSS 선택자 최적화, 이벤트 위임 사용, 읽기/쓰기 DOM 작업 일괄 처리, CSS 애니메이션 사용 등 문제를 완화 시킬 수 있는 기술이 있지만, 복잡하고 구현이 어려울 수 있음
- **브라우저가 레이아웃을 강제로 다시 계산하는 횟수를 최소화하고 계산 시 한 번의 작업으로 필요한 정보를 모두 가져오도록 해야 성능을 높일 수 있음**
    
    **→ 리액트는 가상 DOM을 실제 DOM 작업 간의 중간 계층으로 활용해 작업을 알아서 처리**
    

### 브라우저 간 호환성

- 실제 DOM을 조작할 경우 개발자는 브라우저 간 호환성에 주의를 기울여야 했음
    - 브라우저마다 문서 모델링 방식이 달라 웹 애플리케이션의 일관성이 보장되지 않으며 버그가 발생할 수 있음
    - 또한 특정 DOM 엘리먼트와 속성을 지원하지 않는 브라우저가 있을 수 있음
- **리액트는 합성 이벤트 시스템(Synthetic Event System)을 통해 위 문제를 해결하고자 함**
- Synthetic Event
    - 브라우저의 기본 이벤트를 둘러싼 래퍼 객체
    - 여러 브라우저에서 일관성을 보장하기 위해 설계됨
- SyntheticEvent의 메커니즘
    - 통합 인터페이스
        - 브라우저마다 이벤트 속성 접근 방법이 다른 것과 같은 **차이를 추상화하여 이벤트와 상호작용 하는 일관된 방법을 제공**
        - 예시
            
            ```jsx
            // 리액트를 사용하지 않으면
            // 개별 브라우저마다 속성 확인이 필요
            // IE 8 이하 버전의 경우 event.target 지원 X 
            const targetElemnt = event.target || event.srcElement;
            
            // 리액트에서는 SyntheticEvent 덕분에 일관성이 보장됨
            function handleClick(event){
            	const target = event.target;
            	// ...
            }
            ```
            
    - 이벤트 위임
        - 리액트는 이벤트 리스너를 엘리먼트에 직접 추가하지 않고 루트에서 이벤트를 받아서 처리
            
            → 구형 브라우저의 특정 엘리먼트에서 일부 이벤트를 사용할 수 없는 문제를 방지함
            
    - 다양한 기능 개선
        - 네이티브 브라우저 이벤트의 비일관성에 대한 예시 - onChange 이벤트
            - 기본 자바스크립트에서 onChange이벤트의 동작은 입력 컴포넌트 종류에 따라 달라짐
                - `<input type=”text”>` 의 경우 일부 브라우저에서 onChange 이벤트는 값이 변경되는 즉시 발생하지 않고 입력이 포커스를 잃은 경우에만 발생
                - `<select>`의 경우 브라우저에따라 현재 선택된 옵션을 다시 선택할 때 이벤트가 발생하기도 함
            - 리액트의 SyntheticEvent 시스템은 입력 엘리먼트 전체에서 onChange 이벤트의 동작을 정규화함
                - 텍스트 입력(`<input type=”text”>`)의 onChange 이벤트는 키를 입력할 때마다 발생해 실시간 피드백을 제공함
                - `<select>`에서는 선택한 값이 아닌 옵션을 선택할 때마다 발생함
            - 리액트를 사용하면 개발자가 브라우저의 비일관성을 직접 처리하지 않아도 됨
              
    - 네이티브 이벤트에 접근
        - 웹 브라우저의 네이티브 이벤트가 필요한 경우 event.nativeEvent를 통해 접근 가능
         
        → 추상화의 이점을 그대로 취하면서 필요에 따라 유연하게 사용할 수 있음


### 3.2.2 문서 조각

- 문서 조각
    - DOM 노드를 저장하는 가벼운 컨테이너
    - 기본 DOM에 영향을 주지 않고 여러 가지 업데이트를 수행할 수 있는 임시 저장소처럼 동작
    - 업데이트 작업이 완료되면 문서 조각을 DOM에 추가하는 방식으로 Reflow와 Repaint를 한 번만 발생시킴
    - 리액트의 가상 DOM ≠ 문서 조각
        - 리액트의 가상 DOM은 문서 조각개념을 더 나은 방식으로 구현한 것
        - 업데이트 방식이 유사함
        - 리액트는 문서 조각과 관련된 복잡한 작업을 내부적으로 처리
- 문서 조각의 성능 이점
    - 일괄 업데이트
        - 문서의 실제 DOM을 여러 번 개별적으로 업데이트 하는 대신 문서 조각 내의 모든 변경사항을 일괄적으로 처리함
          
          → Reflow, Repaint는 한 번만 수행됨
    - 메모리 효율성
        - 문서 조각에 추가된 모드는 문서의 실제 DOM에서 제거됨
        
          → 문서에서 큰 영역을 재정렬할 때 메모리 사용량을 최적화하는 데 일조
    - 중복 렌더링 방지
        - 문서 조각은 활성화된 문서 DOM트리에 속하지 않으므로 변경되어도 실제 문서에는 영향을 주지 않음. 또한 실제 DOM에 추가될 때까지 스타일과 스크립트가 적용되지 않음
        
          → 스타일 재계산과 스크립트 실행의 중복 수행을 방지함
- 리액트의 가상 DOM과 문서 조각의 유사점
    - 일괄 업데이트
        - 리액트 가상 DOM은 여러 변경 사항을 한번에 일괄 처리함
        - 리액트는 상태나 프롭이 변경될 때 문서의 실제 DOM을 변경하는 대신 가상 DOM에 변경 사항을 먼저 적용
    - 효율적인 비교 알고리즘
        - 변경 사항이 적용된 후 리액트는 현재 가상 DOM과 실제 DOM의 차이점을 확인함
        - 문서 조각이 직접적인 DOM 조작을 줄이는 것처럼, 위 과정을 통해 실제 DOM에 필요한 변경만 이루어지게 함
    - 단일 렌더링
        - 차이점이 식별되면 단 한 번의 일괄 처리를 통해 실제 DOM을 업데이트함(Reflow, Repaint 최소화)
        - 변경 사항이 모두 반영된 문서 조각을 실제 문서에 추가하는 것과 비슷함

## 3.3 가상 DOM 작동 방식

### 3.3.1 리액트 엘리먼트

- 리액트에서 사용자 인터페이스는 컴포넌트 또는 HTML 엘리먼트의 가벼운 형태인 리액트 엘리먼트의 트리로 표현됨
- 리액트 엘리먼트는 `React.reactElement` 함수를 사용해 생성되며 엘리먼트를 중첩해 복잡한 사용자 인터페이스를 만들 수 있음
- 예시
    
    ```jsx
    const element = React.createElemnt(
    	"div",
    	{className: "my-class"},
    	"Hello, World!"
    );
    console.log(element);
    /*
    	출력 결과
    	{
    		$$typeof: Symbol(react.element),
    		type: "div",
    		key: null,
    		ref: null,
    		props: {
    			className: "my-class",
    			children: "Hello, World!"
    		},
    		_owner: null,
    		_store: {}
    	}
    */
    ```
    
- 리액트 엘리먼트는 리액트 애플리케이션의 가장 작은 구성 블록으로 화면에 표시되어야 할 내용을 설명함
- 각 엘리먼트는 관련 프롭이나 속성과 함께 해당 엘리먼트가 나타내는 컴포넌트를 기술하는 자바스크립트 객체임

### 리액트 엘리먼트 속성

- $$typeof
    - 객체가 유효한 리액트 엘리먼트인지 확인할 때 사용하는 특수한 심벌
    - 엘리먼트의 종류에 따라 값이 다를 수 있음
        - Symbol(react.element), Symbol(react.fragment), Symbol(react.portal), Symbol(react.profiler), Symbol(react.provider), …
        - https://github.com/facebook/react/blob/main/packages/shared/ReactSymbols.js
    - 리액트 엘리먼트의 종류를 식별하는 표시자 역할
- type
    - 엘리먼트가 나타내는 컴포넌트의 종류
    - type 속성은 문자열이거나 함수임(클래스인 경우도 있지만 단계적으로 폐지될 예정이라 생략)
        - 문자열인 경우에는 “div”, “span” 같은 HTML 태그 이름을 표현
        - 함수인 경우 사용자 정의 리액트 컴포넌트(JSX를 반환하는 자바스크립트 함수)가 됨
    - 사용자 정의 리액트 컴포넌트의 경우 리액트가 엘리먼트 깊숙히 들어가 스칼라 값(숫자, 문자열처럼 더 이상 분해되지 않는 하나의 단일값)을 만나면 이를 텍스트 노드로 렌더링함(null or undefined의 경우 렌더링 X)
- ref
    - 부모 컴포넌트는 ref 속성을 사용해 기본 DOM 노드에 대한 참조 요청이 가능
    - 보통 DOM을 직접 조작해야할 경우에 사용
- props
    - 컴포넌트에 전달된 모든 속성과 프롭을 포함하는 객체
    - 예시에 나온 className은 엘리먼트의 클래스 이름을 설정, children은 엘리먼트의 콘텐츠를 포함함
- _owner
    - 프로덕션 빌드가 아닐 때만 접근이 가능한 속성
    - 엘리먼트를 생성한 컴포넌트를 추적하기 위해 리액트에서 내부적으로 사용됨
        
        → 해당 속성 정보를 통해 프롭이나 상태가 변경될 때 엘리먼트의 업데이트를 담당할 컴포넌트를 결정하는데 사용됨
        
    - 내부적으로 구현을 위해 사용하는 값이므로 애플리케이션 코드에서 사용하면 안 됨
- _store
    - 엘리먼트에 대한 추가 데이터를 저장하기 위해 리액트가 내부적으로 사용하는 객체
    - 저장되어있는 특정 속성 및 값은 공개 API의 일부가 아니므로 직접 접근해서는 안됨

### 3.3.2 가상 DOM과 실제 DOM 비교

- **`React.createElement` vs `document.createElement` 메서드**
    - 둘 다 새로운 엘리먼트를 생성한다는 점에서 유사함
    - React.createElement는 리액트 엘리먼트를, document.createElement는 DOM 노드를 생성
- 예시 - `<div>` 엘리먼트 만들기
    
    ```jsx
    // 리액트 createElement
    const divElement = React.createElement(
    	"div",
    	{className: "my-class"},
    	"Hello, World!"
    );
    // DOM API의 createElement
    const divElement = document.createElement("div");
    divElement.className = "my-class";
    divElement.textContent = "Hello, World!";
    ```
    
    - **`React.createElement`**
        - 메모리에 새로운 가상 엘리먼트를 생성하는 함수
        - 첫 번째 인수를 태그 이름으로 사용하며, 프롭과 자식을 지정하는 추가 인수를 받음
    - **`document.createElement`**
        - document.appendChild 등의 API로 DOM에 추가되기 전 메모리에 새로운 엘리먼트를 생성하는 메서드
        - 첫 번째 인수를 태그 이름으로 사용
- 리액트 컴포넌트가 렌더링되면 리액트는 새 가상 DOM 트리를 생성하고 이전 가상 DOM 트리와 비교 후 이전 트리를 새 트리와 일치하도록 업데이트하는 데 필요한 최소 변경 횟수를 계산함 
→ 재조정 프로세스

### 3.3.3 효율적인 업데이트

- 리액트는 비교 알고리즘을 사용하여 새 트리를 이전 트리와 비교해 실제 DOM의 업데이트에 필요한 최소한의 변경 사항을 결정함
- 새 트리와 이전 트리를 비교하는 과정은 **재귀적**으로 이루어지며, 노드가 변경된 경우 실제 DOM에서 해당 노드를 업데이트하고 노드가 추가(또는 삭제)된 경우 실제 DOM에서 해당 노드를 추가(또는 삭제)
    
    **→ 새 트리와 이전 트리를 노드 별로 비교해 변경 부분을 알아내는 작업을 디핑(diffing)이라고 하고, 이 때 사용하는 알고리즘을 디핑 알고리즘이라고 함**
    
- 디핑 알고리즘 작동 방식
    - 두 트리의 루트에 있는 노드가 다른 경우, 기존 트리를 전체 새 트리로 대체
    - 루트 노드가 동일하다면, 노드의 속성이 변경된 경우에만 업데이트
    - 자식 노드가 다른 경우, 변경된 자식 노드만 업데이트(하위 트리 전체를 다시 생성하지 않고 변경된 노드만 업데이트)
    - 노드의 자식들이 동일하지만 순서가 변경된 경우, 노드를 다시 생성하지 않고 실제 DOM에서 노드의 순서를 다시 설정
    - 트리에서 노드가 제거되면 실제 DOM에서 노드를 제거
    - 트리에 새 노드가 추가되면 해당 노드를 실제 DOM에 추가
    - 노드의 종류가 변경된 경우(div → span), 이전 노드를 제거하고 변경된 종류의 새 노드를 생성
    - 노드에 key 프롭이 있다면 이를 활용해 노드의 교체가 필요한지 파악. 이는 컴포넌트 상태를 재설정할 때 유용함

### 불필요한 리렌더링

- 리액트의 디핑 알고리즘은 필요한 변경 사항을 최소화해 실제 DOM을 효율적으로 업데이트함
- 리액트는 컴포넌트 상태가 변경되면 컴포넌트와 모든 자손 컴포넌트를 리렌더링하도록 설계되었으므로 이 부분을 주의해서 개발해야 함
    - 크고 복잡한 사용자 인터페이스를 처리할 때 성능에 부담을 줄 수 있으므로 아래와 같은 방법을 통해 관리 필요
        - 상위 컴포넌트의 상태나 프롭이 변경되더라도 하위 컴포넌트에 불필요한 리렌더링이 발생하지 않도록 **컴포넌트 렌더링을 신중하게 관리**할 것
        - 컴포넌트를 **주의 깊게 구조화**하고 **memo 혹은 useMemo와 같은 최적화 기능을 사용**해 관리할 것
