# 9장 리액트 서버 컴포넌트
- RSC는 서버에서 실행되는 컴포넌트로 클라이언트 자바스크립트 번들에 포함되지 않음
- 빌드 시점에 실행될 수 있기 떄문에 파일 시스템에서 데이터를 읽거나 정적 콘텐츠를 가져오거나 데이터 레이어에 접근하는 등의 작업이 가능
- 서버 컴포넌트에서 데이터를 브라우저 환경에 있는 클라이언트 컴포넌트의 프롭으로 전달함으로써 매우 효율적이고 성능이 뛰어난 애플리케이션을 작성할 수 있음
- 서버 컴포넌트와 클라이언트 컴포넌트 모두 리액트 엘리먼트를 반환. 서버 컴포넌트의 경우 반환된 결과가 네트워크를 통해 클라이언트로 전송됨

## 9.1 장점
- 우리가 계산 능력을 제어할 수 있는 서버에서만 실행됨. 예측하기 어려운 클라이언트 기기에서 실행하는 것이 아니기 때문에 성능을 더 잘 예측하게 됨
- 안전한 서버 환경에서 실행되므로 토큰과 같은 민감한 정보가 유출될 걱정 없이 서버 컴포넌트에서 안전하게 작업을 수행할 수 있음
- 비동기로 동작할 수 있음. 따라서 네트워크를 통해 클라이언트로 전송하기 전에 서버 컴포넌트의 동작이 완료될때까지 기다릴 수 있음

## 9.2 서버 렌더링
- 서버 컴포넌트와 서버렌더링은 두 개의 독립적인 프로세스로 생각할 수 있음
  - 한 프로세스(RSC 렌더러)는 서버에서 컴포넌트를 렌더링한 후 리액트 엘리먼트 트리를 생성
  - 다른 프로세스(서버 렌더러)는 이렇게 생성된 리액트 엘리먼트 트리를 마크업으로 변환 -> 네트워크를 통해 클라이언트에 스트리밍됨
- 서버 컴포넌트와 서버 렌더링의 상호작용
  - 1. 서버에서 JSX 트리는 엘리먼트 트리로 변환됨
  - 2. 서버는 이 엘리먼트 트리를 문자열이나 스트림으로 직렬화
  - 3. 문자열로 변환된 JSON 객체가 클라이언트로 전송됨
  - 4. 클라이언트측의 리액트는 JSON 문자열을 파싱해 읽고 평소와 다름없이 렌더링
- 직렬화: 데이터나 객체를 저장하거나 전송하기 위해 일련의 바이트나 문자열 형태로 변환하는 과정

### 9.2.1 내부 구조
- 서버에서 엘리먼트 트리를 만드는 과정에서 turnServerComponentsIntoTreeOfElements라는 함수를 사용
- 이 함수는 리액트 렌더러의 한 종류로 <App/>과 같은 상위 단계에서 시작해 재귀적으로 컴포넌트를 호출하고, 여기서 반화되는 리액트 엘리먼트를 가져옴
- 동작
  - 만약 간단한 문자열이라면 클라이언트와 서버에서 모두 이해하고 렌더링이 가능하므로 그냥 반환
  - 만약 배열이 전달된다면(fragment 등을 통해) 배열의 map을 실행하고 함수를 실행해 재귀적으로 배열의 각 엘리먼트를 처리
  - 만약 객체라면
    - 리액트 엘리먼트인지를 $$typeof 속성을 통해 확인 (Symbol.for('react.element'))
      - jsx.type이 string이라면 내장된 DOM 엘리먼트이므로 그대로 반환
      - 함수타입이라면 사용자가 작성한 컴포넌트를 나타내는 것이므로 해당 컴포넌트를 프롭과 함께 호출하고, 컴포넌트가 반환하는 JSX에 대해 재귀적으로 함수 호출
        - 문자열,숫자,불리언 또는 배열, 문자열 타입의 리액트 엘리먼트가 반환될때까지 반복
        - 함수 타입은 await 키워드가 있는데 비동기 작업이 완료될때까지 기다리게 하는 역할을 함
    - 객체지만 리액트 엘리먼트가 아닌 경우
      - (보통 프롭으로 사용되는 경우) 
      - 해당 객체의 각 값에 대해 함수를 재귀적으로 호출하고 결과를 반환
- 이제 해당 엘리먼트 트리를 renderToString이나 renderToPipeableStream과 같은 함수에 전달 / 직렬화해서 브라우저로 직접 전송

**직렬화**
- 초기 로드 중에 애플리케이션이 올바르고 효율적으로 렌더링되도록 보장하는 데 매우 중요한 작업
- 서버에서 렌더링된 동일한 출력이 클라이언트와 일치해야만 리액트가 올바르게 재조정하고 차이점을 파악할 수 있음
- 애플리케이션이 서버에서 렌더링될때, 생성된 리액트 엘리먼트는 브라우저로 전송될 수 있는 HTML 문자열로 변환되어야 함. 이 과정을 직렬화라고 함
- ReactDOMServer.renderToString 같은 함수를 사용해 직렬화 -> 리액트 엘리먼트 트리를 탐색해 각 엘리먼트에 해당하는 HTML을 생성하고 이를 모두 합쳐 하나의 HTML 문자열로 만듦
- 그 다음 이 문자열을 클라이언트로 전송해 페이지의 초기 마크업으로 사용
- 자바스크립트 번들이 클라이언트에 로드되면 리액트는 이벤트 핸들러를 추가하고 동적 콘텐츠를 채우면서 DOM을 하이드레이트
- 직렬화 단계의 중요성
  - 1. 서버가 즉시 표시할 수 있는 완전한 HTML 페이지를 빠르게 클라이언트에 전송할 수 있음(체감 로딩 속도가 빨라짐)
  - 2. 환경에 관계없이 예측 가능한 초기 렌더링이 가능(정적이며 서버에서 렌더링되든 클라이언트에서 되든 동일하게 표시됨)
  - 3. 클라이언트 측의 하이드레이션 프로세스를 용이하게 함 -> 리액트가 작업할 수 있는 견고한 기반을 확보해 다시 실행하는 하이드레이션 프로세스를 보다 효율적이고 안정적으로 함
- 컴포넌트도 문자열로 직렬화해야하지만 평범한 자바스크립트 객체가 아니기 때문에 JSON.stringify만으로는 불가($$typeof 속성에 유의하여 직렬화해야함)

**페이지 탐색**
- RSC를 사용하면 소프트 내비게이션을 구현할 수 있으며, 이 경우에는 경로가 변경되어도 상태가 유지됨
  - 이동하고자 하는 URL을 서버로 전송하면 서버는 해당 페이지의 JSX 트리를 반환. 이후 브라우저의 리액트가 새로운 JSX 트리를 사용해 전체 페이지를 다시 렌더링하기 때문에 새로고침하지않고도 새로운 페이지 볼 수 있음
- 구현방법: a 태그의 기본동작을 막고 navigate 함수를 정의하여 구현 

### 9.2.2 업데이트
- 서버 컴포넌트는 클라이언트 전용 API인 useState나 onClick를 사용할 수 없음 + 서버컴포넌트의 prop으로 함수가 들어올 수 없음(함수는 직렬화가 불가능하므로 직렬화하여 클라이언트로 전송할 수가 없기 때문)
- 클라이언트 컴포넌트와 서버 컴포넌트를 잘 분리하여 작성 
- 잘분리한다면 작은 부분만이 자바스크립트의 번들로 사용자에게 전송될 것이고 CPU 측면에서는 자바스크립트를 파싱하고 실행하는 작업이 감소하고 네트워크 측면에서는 다운로드해야하는 데이터 양이 적어짐

**내부 동작**
- 'use client' 지시자를 통해 클라이언트와 서버 컴포넌트를 구분
- 서버 컴포넌트 하위에 클라이언트 컴포넌트가 있다면 placeholder를 렌더링(클라이언트 번들러가 생성한 특정 모듈에 대한 참조)
- 리액트가 트리를 렌더링하다가 모듈 참조를 만나면 모듈 참조를 클라이언트 번들의 실제 모듈로 대체
- 서버 컴포넌트는 Suspense 경계로 감쌀 수 있고 프레임워크가 필요한 작업을 수행하여 서버 컴포넌트가 준비될때마다 스트리밍할 수 있음

### 9.2.3 주의할 점
- 클라이언트 컴포넌트는 클라이언트에서만 실행되는 것은 아님. 서버컴포넌트는 맞음
- 여기서 실행은 컴포넌트를 표현하는 함수가 호출된다는 것(본문이 실행된다는 것은 아님)
- 클라이언트 컴포넌트는 서버에서 실행되고 리액트 엘리먼트를 나타내는 객체를 출력

## 9.3 서버 컴포넌트 규칙
### 9.3.1 직렬화 가능성이 가장 중요
- 서버 컴포넌트에서는 모든 프롭을 직렬화할 수 있어야 함(함수 전달불가, 렌더 프롭 패턴 사용 불가)

### 9.3.2 부작용이 있는 훅 금지
- 서버 환경은 인터랙티브하지도 않고 DOM이나 window 객체도 없음 따라서 DOM 업데이트, 상태변경, 데이터페칭같은 훅을 사용할 수 없음
- but useRef 같은 훅은 사용 가능

### 9.3.3 상태는 동일하지 않다
- 서버와 클라이언트의 관계는 1:1이 아니라 1:N의 관계로 하나의 서버가 다수의 클라이언트에 대응하고 있음
- 서버의 상태가 여러 클라이언트에 공유될 수 있고 이로 인해 클라이언트의 상태가 다른 클라이언트에 노출될 위험이 있음
```jsx
let userInfo = null; // 모든 클라이언트가 이 변수를 공유함

export default function ServerComponent() {
  // 사용자 정보를 저장
  userInfo = { name: "현재 접속한 사용자", data: "민감한 정보" };
  
  return <div>사용자: {userInfo.name}</div>;
}
```
- 서버에서 요청별로 독립적인 처리를 하고 상태를 클라이언트 컴포넌트에서 관리하도록 해야함

### 9.3.4 클라이언트 컴포넌트는 서버 컴포넌트를 가져올 수 없다
- 서버 컴포넌트는 서버에서만 실행되지만 클라이언트 컴포넌트는 양쪽 모두에서 실행되기 때문

```jsx
import ServerComponent from "./ServerComponent";

export default function ClientComponent() {
  return (
    <div>
      <ServerComponent />
    </div>
  );
}
```

- 클라이언트 컴포넌트에서 Import를 통해 번들에 서버 컴포넌트를 포함해서는 안됨
- 아래와 같은 패턴은 가능

```jsx
import ServerComponent from "./ServerComponent";

async function ParentComponent(){
    return <ClientComponent>
        <ServerComponent />
    </ClientComponent>
}
```

### 9.3.5 클라이언트 컴포넌트는 나쁘지 않다

## 9.4 서버 액션
- RSC는 'use server'라는 지시자를 사용해 클라이언트 코드에서 호출할 수 있는 서버 함수를 표시하는데, 이러한 함수를 가리켜 서버 액션이라고 함
- 비동기 함수의 본문 첫줄에 'use server'를 추가하면, 리액트와 번들러는 이 함수를 클라이언트에서 호출할 수 있지만 서버에서만 실행되는 함수로 취급
- 클라이언트에서 서버 액션을 호출할 때, 함수에 전달된 모든 인수는 직렬화되어 네트워크를 통해 서버에 전달됨.
- 서버 액션이 값을 반환하면, 반환된 값은 직렬화되어 클라이언트에서 반환됨

### 9.4.1 폼과 데이터 조작
```jsx
async function requestUserName(formData){
    'use server'
    const name = formData.get('name')
}

export default App(){
    return (
        <form action={requestUserName}>
            <input type="text" name="name" />
            <button type="submit">전송</button>
        </form>
    )
}
```

### 9.4.2 폼 외부
- 서버 액션은 서버 엔드포인트로 노출되며 클라이언트 코드 어디서든 호출할 수 있음
- 폼이 아닌 곳에서 서버 액션을 사용하는 경우, 트랜지션 내부에서도 서버 액션을 호출할 수 있음
- 이를 통해 로딩 메세지를 표시하고 낙관적인 상태 업데이트를 보여주며 예상치 못한 오류를 처리할 수 있음
- 기본 리액트에서 서버 액션을 사용하기에는 설정이 번거로우므로 프레임워크를 사용하는 것이 좋음

```jsx
'use client'

import { useState, useTransition } from 'react';

function Likebutton(){
    const [isPending, startTransition] = useTransition();
    const [likes, setLikes] = useState(0);
  
    function requestLike(likes){
        'use server'
        // 서버에서 좋아요 수를 업데이트하는 로직
    }

    function handleClick(){
        startTransition(async () => {
            const newLikes = await requestLike(likes + 1);
            setLikes(newLikes);
        });
    }

    return (
        <button onClick={handleClick}>
            {isPending ? 'Loading...' : `Like ${likes}`}
        </button>
    )
}
```

## 9.5 리액트 서버 컴포넌트의 미래
- 추가 개발 진행중인 영역
  - 더 나은 번들러 통합
    - 웹팩, 롤업, Vite와 같은 다양한 번들러와의 통합을 통해 서버 컴포넌트를 보다 쉽게 사용할 수 있도록 지원
  - 생태계 지원
    - 새로운 애플리케이션 아키텍처를 지원하고 확장하는 도구, 라이브러리 및 프레임워크 등이 등장할 것