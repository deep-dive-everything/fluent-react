# 5장 자주 묻는 질문과 유용한 패턴

### 5.1 React.memo를 사용한 메모화

- 메모화 : 이전에 계산된 결과를 캐싱해서 다시 계산하지 않으며 함수의 성능을 최적화하는 기법
    - 메모화를 사용하기 위해서는 함수가 순수해야 한다.
        - 순수한 함수 : 주어진 입력에 대해 동일한 출력 ⇒ 네트워크 통신 의존한다면 메모화 불가능
    - 비용 많이 드는 계산 처리, 항목이 많은 목록 렌더링 시, 유용
- React.memo
    - 프롭 변경 시에만 재렌더링 👍🏻
    - 업데이트 발생 시, 리액트 작동 방식
        - 업데이트 발생 시, 컴포넌트를 이전 렌더링에서 반환된 가상 DOM 결과와 비교
        - **프롭 변경**으로 비교 결과가 다르다면 재조정자는 이미 엘리먼트가 호스트 환경에 존재하는 경우 업데이트 효과 실행, 존재하지 않는 경우 배치 효과 실행
            - **업데이트 효과 (Update Effect)**
                - 기존 엘리먼트(호스트 환경에 존재하는 경우)가 다시 렌더링되었을 때 적용됨.
                - React는 변경된 부분만 찾아서 효율적으로 업데이트함.
                - 예를 들어, `className`이 변경되었거나 `onClick` 핸들러가 변경되었다면 해당 속성만 업데이트됨.
            - **배치 효과 (Batch Effect)**
                - 기존에 없던 요소(호스트 환경에 존재하지 않는 경우)가 새롭게 추가되었을 때 적용됨.
                - React는 해당 요소를 DOM에 추가하고 필요한 초기화 과정을 수행함.
                - 예를 들어, `useEffect`의 초기 실행이나 새로운 DOM 노드가 추가되는 경우 해당 효과가 적용됨.
            - 프롭이 동일하더라고 컴포넌트 재렌더링이 발생할 수 있음 ⇒ 이 때, **React.memo** 활용하면 불필요한 렌더링 문제 해결 ✨
    - 프롭에 얕은 비교를 수행해 프롭의 변경 여부 확인 ⇒ 참조 타입의 경우 불필요한 렌더링 발생⇒ 값은 useMemo, 함수는 useCallback훅 사용으로 문제 해결 ✨
        - useCallback훅 ⇒ 이전 함수 참조를 재사용
        - 함수에도 useMemo를 사용할 수 있기는 하나, 비효율적
    - React.memo는 프롭 변경 시에만 리렌더링이 효율적으로 일어나도록 리액트에 힌트를 전할 뿐 모든 작업은 리액트 책임 ⇒ React.memo 사용은 강제가 아닌 권장 사항
        - 컴포넌트 트리 변경, 전역 상태 변경 발생 시, 메모화된 컴포넌트도 재렌더링이 발생하므로 항상 리렌더링을 방지하는 것도 아님

### 5.2 useMemo를 사용한 메모화

- React.memo : 전체 컴포넌트를 메모화해 재렌더링 발생 방지
- useMemo : 컴포넌트 내부의 특정 계산을 메모화 해 **재계산을 피하고** **결과에 대한 일관된 참조 유지**
    - 나쁜 사례
        - 스칼라 타입 비교
        - 무상태 컴포넌트 : 내부에서 상태를 사용하지 않는 React 컴포넌트 ⇒ 이럴 때는 프롭에 의해서만 렌더링이 결정되므로 React.memo 사용
- 리액트에서 내장 컴포넌트/호스트 컴포넌트의 프롭과 사용자 정의 컴포넌트 프롭과의 차이

|  | **내장 컴포넌트 (HTML 태그)** | **사용자 정의 컴포넌트 (React 컴포넌트)** |
| --- | --- | --- |
| **렌더링 방식** | 브라우저가 직접 해석 | React가 함수 실행 후 내장 컴포넌트로 변환 |
| **프롭 전달** | DOM 속성으로 직접 전달됨 | 일반 JavaScript 객체로 전달됨 |
| **이벤트 처리** | 자동으로 `addEventListener`를 통해 등록됨 | 명시적으로 전달하지 않으면 하위 컴포넌트로 전달되지 않음 |

⇒  내장 컴포넌트 메모화하면 득보다 실이 많을 수 있기 때문에 리액트는 내장 메모화를 미제공

⇒ DOM 요소에는 메모화 개념이 없음

- useCallback 사용 좋은 사례
    - 자주 리렌더링할 가능성 있는 컴포넌트가 있을 때, 하위 컴포넌트에 콜백을 전달할 때, 하위 컴포넌트가 React.memo 또는 shouldComponentUpdate로 최적화된 경우
        - 콜백을 메모화하면 부모 컴포넌트를 렌더링할 때, 자식 컴포넌트가 불필요하게 재렌더링하지 않음

### 5.2 지연 로딩

애플리케이션의 규모가 커지면서 자바 스크립트 코드 양도 증가한다. 자바 스크립트를 너무 많이 전송하며 데이터 사용량도 증가하는데 데이터 요금제, 인터넷 연결 상태에 따라 비용 증가, 로딩 시간 지연 문제가 생길 수 있다. 이를 코드 분할, 지연 로딩을 통해 해결할 수 있다. ✨

- 코드 분할 : 특정 페이지나 기능에 필요한 자바스크립트만 읽어들이는 방법
- 지연 로딩 : 초기 실행에 필수적이지 않은 자바 스크립트의 로딩을 미루는 것

 ⇒ 페이지 로딩 시간, 데이터 사용량 감소

- Suspense : Promise가 해결되기 전까지 폴백 컴포넌트를 표시하는 컴포넌트

⇒ 사용자에게 즉각적인 피드백을 제공 👍🏻
