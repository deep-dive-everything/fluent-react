# 1. React.memo를 사용한 메모화

- 메모화 : 이전에 계산된 결과를 캐싱해서 함수 성능을 최적화하는 기법.
- 계산 비용이 많이 들거나 자주 호출되는 함수를 실행하는데 필요한 시간과 리소스를 줄일 수 있음.
- 함수의 순수성 : 함수가 주어진 입력에 대해 동일한 출력을 에측 가능하게 변환해야함.
- React.memo : 프롭이 변경되었을 때만 반환하는 컴포넌트를 다시 렌더링함.
- 불필요한 렌더링을 방지해 성능이 전반적으로 향상됨
- 메모화는 비용이 큰 계산의 결과를 저장했다가 동일한 입력이 함수에 전달되거나 동일한 프롭이 컴포넌트에 전달될 때 저장해 둔 결과를 반환하는 방식으로 렌더링이 오래 걸리는 문제 방지

## 1.1 React.memo에 능숙해지기

- 업데이트가 발생하면 이전 렌더링에서 변환된 가상DOM의 결과와 비교. 이때 React.memo를 사용하면 각 렌더링 사이 프롭이 동일한 경우 불필요한 렌더링을 피할 수 있음.

## 1.2 리렌더링 되는 메모화된 컴포넌트

- 스칼라 타입 : 원시타입. 기본 자료형. 단일한 개별 값. 속성이나 메서드가 없으며 본질적으로 불변함.
- 스칼라가 아닌 타입 : 참조 타입. 데이터 자체가 아니라 데이터가 메모리에 저장된 위치에 대한 참조 또는 포인터를 저장함. 객체와 배열. 함수. 내용은 같지만 메모리 위치가 다른 경우 동등하지 않은것으로 간주함.
- ⇒ useMemo 훅으로 배열을 메모화 하면 문제를 해결할 수 있음.
- 함수를 참조로 비교해 문제가 생기는 경우 useCallback 훅으로 문제를 해결할 수 있음.

## 1.3 강제가 아닌 권장 사항

- 컴포넌트 트리의 변경이나 애플리케이션 전역 상태 변경이 발생하면 리액트가 메모화된 컴포넌트를 다시 렌더링 할 수 있으므로 React.memo가 항상 리렌더링을 방지하는 것은 아님.
- 메모화 된 컴포넌트를 업데이트 해야하는지 아니면 업데이트를 건너뛸 수 있는지 판단할 수 있는 함수.

# 2 useMemo를 사용한 메모화

- React.memo는 전체 컴포넌트를 메모화해 렌더링이 다시 발생하지 않게 함
- useMemo는 컴포넌트 내부의 특정 계산을 메모화함.

## 2.1 useMemo의 나쁜 사례

- useMemo는 계산 비용이 많이 드는 연산을 메모화 하거나 객체와 배열에 대한 안정적인 참조를 유지하는데 유용함.
- 스칼라값은 useMemo를 사용할 필요가 없음.
- 내장 컴포넌트에서 함수 프롭을 사용하는 경우
    - 직접 전달 : 함수 프롭을 내장 컴포넌트에 전달하면 리액트가 실제 DOM엘리먼트에 직접 전달함.
    - 렌더링 동작 : 내장 컴포넌트는 상위 컴포넌트의 일부가 아니라면 함수 프롭의 변경에 의해서는 리랜더링 되지 않음.
    - 함수에 대한 가상 DOM과 비교하지 않음
    - 이벤트 풀링
- 내장 컴포넌트는 메모화 할때 이득 없이 부하가 추가되기 때문에 메모화를 제공하지 않음.
- useCallback은 자주 리렌더링 할 가능성이 있는 컴포넌트가 있고 하위 콜백을 전달할 때 유용함 : 부모 컴포넌트를 렌더링 할 때 자식 컴포넌트가 불필요하게 다시 렌더링하지 않음. 본질적으로 함수를 위한 useMemo임

## 2.2 모두 잊고 포겟하세요

- 리액트 컴파일러  : 메모화를 자동화하기 위한 새로운 도구
