> 메모화, 지연 로딩, 성능

> [!NOTE]
>
> #### 메모화
>
> - 컴퓨터 과학에서 이전에 계산된 결과를 캐싱해서 함수의 성능을 최적화하는 기법
>   - 비용이 많이 드는 계산을 처리해야 할 경우
>   - 항목이 많은 목록을 렌더링할 경우

## `memo`

```jsx
const MemoizedComponent = memo(SomeComponent, arePropsEqual?)
```

- 함수 컴포넌트를 메모화하여 새로운 메모된 컴포넌트를 반환
- prop이 변경되었을 때만 리렌더링
  - '렌더링한다' → _'컴포넌트 함수를 다시 호출한다'_
  - `memo`로 감싸진 함수는 **prop이 변경되지 않는 한 재조정 과정에서 다시 호출되지 않음**
- 언제 메모화가 필요할까? → 렌더링 비용이 많이 들거나 로직이 복잡한 컴포넌트
- 컴포넌트를 메모화하면..
  - 변경된 컴포넌트 → 리렌더링
  - 변경되지 않은 컴포넌트 → 리렌더링이 발생하지 않고 캐시된 출력 사용

### 메모화를 사용할 때 주의할 점

> 그렇다면 얼마나 자주 메모화해야 할까?<br/>
> 모든 컴포넌트를 메모화하면 애플리케이션 전체의 성능이 더 좋아질까?

`memo`를 사용해도 메모화가 되지 않는 경우가 있음 → `useMemo`, `useCallback`를 같이 사용해서 해결할 수 있음

#### `useMemo`가 필요한 경우

```tsx
const List = memo(function List({ items }) {
  return (
    <ul>
      {items.map(item => (
        <li key={item}>{item}</li>
      ))}
    </ul>
  )
})
```

```tsx
function ParentComponent({ allFruits }) {
  const [count, setCount] = useState(0)
  const favoriteFruits = allFruits.filter(fruit => isFavorite(fruit))

  return (
    <div>
      <button onClick={() => setCount(count + 1)}>증가</button>
      <List items={favoriteFruits} />
    </div>
  )
}
```

- 증가 버튼을 클릭할 때마다 `ParentComponent` 리렌더링
- 이때, `memo`는 prop을 얕게 비교하기 때문에 새 배열 인스턴스를 이전 렌더링에서 사용한 배열과 다른 prop으로 간주해 `List` 컴포넌트에서 불필요한 리렌더링 발생
- ✨ 배열이 한 번만 생성되고 렌더링이 새롭게 되더라도 동일한 참조를 유지할 수 있게 `useMemo` 사용

```tsx
const favoriteFruits = useMemo(() => allFruits.filter(fruit => isFavorite(fruit)), [allFruits])
```

#### `useCallback`이 필요한 경우

- 자바스크립트에서는 함수를 참조로 비교하기 때문에 prop이 다르다고 판단해 컴포넌트가 메모화되지 않음
- 현재 사용자 정보 같은 의존성 배열 항목이 변하지 않는 한 onAvatarChange는 절대 변경되지 않음
- 함수가 prop으로 전달되는 컴포넌트를 메모화할 때 권장

### `memo`의 작동 방식

- 업데이트가 발생하면 리액트는 컴포넌트를 이전 렌더링에서 반환된 가상 DOM 결과와 비교
- prop이 변경되어 비교 결과가 다르다면, 재조정자는 엘리먼트가 호스트 환경(브라우저 DOM)에 이미 존재하는 경우에는 업데이트 효과를 실행하고, 그렇지 않은 경우에는 배치 효과를 실행
- prop이 동일하더라도 컴포넌트는 다시 렌더링되고, 이에 따라 DOM도 업데이트 될 수 있음

> 컴포넌트 트리의 변경이나 애플리케이션의 전역 상태 변경이 발생하면, 리액트가 메모화된 컴포넌트를 다시 렌더링할 수 있으므로 React.memo가 항상 리렌더링을 방지하는 것은 아닙니다.

```tsx
function memo(type, compare) {
  return {
    $$typeof: REACT_MEMO_TYPE,
    type,
    compare: compare === undefined ? null : compare,
  }
}
```

- 요약하자면, updateMemoComponent는 메모화된 컴포넌트를 업데이트해야 하는지 아니면 성능 최적화를 위해 업데이트를 건너 뛸 수 있는지 판단하는 역할
  - 최초 렌더링과 업데이트를 모두 처리
  - 새 파이버를 생성해야 하는지 아니면 기존 파이버를 업데이트해야 하는지에 따라 다른 작업 수행
- 이전 렌더링 없음 (최초 마운트)
  - current === null → 컴포넌트 처음 마운트 → 무조건 렌더링
  - 컴포넌트가 렌더링할 새 파이버 생성되고 반환
- 단순 함수 컴포넌트 최적화
  - 컴포넌트가 단순 함수 컴포넌트(defaultProps x, custom compare 함수 x) → SimpleMemoComponent로 최적화
  - 이렇게 하면 얕은 비교만으로 업데이트 여부 결정 가능 → 빠른 업데이트 경로 사용 가능
- 비교 함수
  - 이전 렌더링이 있다면 비교 함수가 false를 반환할 때만 컴포넌트 업데이트
  - 커스텀 compare 함수 혹은 기본 제공되는 얕은 비교(shalloEqual) 함수 사용
  - 새 prop이 이전 prop과 동등 + 동일한 ref → 리렌더링 X, 렌더링 프로세스에서 벗어남
- 개발 모드에서 기본 prop과 prop 타입
  - defaultProps: 지원 중단될 예정이라 있다면 경고 메시지 출력
  - checkPropTypes: propTypes 유효성 검사
- 빠른 종료 조건
  - 예정된 업데이트 또는 콘텍스트 변경이 없는 경우, 비교 함수는 이전 prop과 새 prop이 동일하다고 간주하고 ref가 변경되지 않으면 bailoutOnAlreadyFinishedWork 결과를 반환해 리렌더링을 효과적으로 생략
  - hasScheduledUpdateOrContext이 false
  - 그러나 예정된 리액트 콘텍스트 업데이트가 있는 경우에는 prop이 변경되지 않았더라도 컴포넌트를 다시 렌더링
    - 콘텍스트 업데이트가 컴포넌트 prop의 범위 바깥에 있는 것으로 간주되기 때문
    - 리렌더링 일으키는 경우: 상태 변경, 콘텍스트 변경, 예전된 업데이트
- 수행된 작업 플래그
  - 업데이트가 필요한 경우에는 작업용(workInProgress) 파이버에 PerformedWork 플래그를 설정해 현재 렌더링 중에 이 파이버가 작업을 수행했다고 표시

> - 즉, React.memo 컴포넌트는 상태나 컨텍스트 변경에 의해 예정된 업데이트가 없고, 기존 prop과 새 prop을 비교한 결과 두 prop이 동일하다면 다시 렌더링되지 않습니다.

- prop을 비교할 때는 기본값으로 제공되는 얕은 비교 함수 혹은 커스텀 비교 함수를 사용합니다.

## `useMemo`

- 좋은 사례

```tsx
const People = () => {
  const [name, setName] = useState('')
  const sortedPeople = useMemo(
    () => [...unsortedPeople].sort((a, b) => b.age - a.age),
    [unsortedPeople],
  )
}
```

- 나쁜 사례
- 문자열, 숫자, 불리언 같은 스칼라 값은 useMemo를 사용할 필요가 없다
  - 스칼라 값을 설정하거나 비교할 때 실제로 다루게 되는 것은 변경 가능한 메모리 위치에 대한 참조가 아닌 값 그 자체
- 리액트 내장 컴포넌트 또는 div, button 같은 호스트 컴포넌트(브라우저 네이티브 엘리먼트)는 함수 prop(onClick 핸들러같은) 등의 프롭을 커스텀 컴포넌트와 조금 다르게 취급
  - 직접 전달
    - 함수 프롭을 내장 컴포넌트에 전달하면 리액트는 이를 실제 DOM 엘리먼트에 직접 전달
    - 특히 이벤트 기반 프롭이면 → 리액트는 이벤트 핸들러를 DOM 엘리먼트에 직접 추가하는 대신 이벤트 위임을 사용해 이벤트 처리 (리액트의 내부 처리)
  - 렌더링 동작
    - 내장 컴포넌트는 리렌더링된 상위 컴포넌트의 일부가 아니라면, 함수 prop 변경에 의해서는 리렌더링되지 않음
    - 그리고 부모 컴포넌트가 리렌더링해서 내장 컴포넌트에 새로운 함수를 prop으로 전달하는 경우 → 내장 컴포넌트는 prop이 변경되었기 때문에 리렌더링 → 그러나 이때의 리렌더링은 최적화할 필요가 없을 만큼 일반적으로 빠름
  - 함수에 대한 가상 DOM 비교하지 않음
    - 내장 컴포넌트에 대한 가상 DOM 비교는 함수 prop의 동일성을 기반
    - 근데 인라인 함수를 전달하면 컴포넌트 렌더링마다 새로운 함수가 되지만
    - 리액트가 변경 사항 감지를 위한 깊은 비교 수행 x
    - 그냥 리렌더링마다 새 함수는 DOM 엘리먼트에 설정된 기존 함수 대체 → 성능 절약
  - 이벤트 풀링
    - 리액트는 이벤트 핸들러이에 이벤트 풀링을 사용해 메모리 부하를 줄임
    - 이벤트 핸들러에 전달되는 이벤트 객체는 풀링된 합성 이벤트 → 여러 이벤트에 재사용 → 가비지 컬렉션 부하 줄임
    - 풀링: 자원을 효율적으로관리하기 위해 미리 생성된 자원을 재사용하는 기법

> 실질적으로 리렌더링 비용이 많이 드는 사용자 정의 컴포넌트에 새 함수 인스턴스를 전달할 때는 주의를 기울여야 하지만, 내장 컴포넌트를 사용할 때는 신경을 덜 써도 됩니다. 그러나 함수를 새로 생성하고 전달하는 것에 대해서는 항상 주의하는 편이 좋습니다. 불필요한 함수 생성은 가비지 컬렉션을 자주 유발하며, 업데이트가 매우 잦은 경우에는 성능 문제로도 이어질 수 있습니다.

- 따라서 useCallback은 크게 도움이 되지 않음
  - useCallback을 가져와서 호출하고 의존성을 전달한 다음 의존성을 비교해 함수를 다시 계산하는 비용이 더 크기 때문 → 성능에 이롭기보다 해로운 런타임 복잡성 초래
- useCallback의 좋은 사례
  - 자주 리렌더링할 가능성이 있고 하위 컴포넌트에 콜백을 전달할 때,
  - 하위 컴포넌트가 React.memo 또는 shouldComponentUpdate로 최적화된 경우
  - 콜백을 메모화하면 부모 컴포넌트를 렌더링할 때 자식 컴포넌트의 불필요한 리렌더링 발생하지 않음

```tsx

```

- 자식 컴포넌트 렌더링의 비용이 비싸서 렌더링 횟수를 줄여 성능을 최적화하려는 경우에 유용
- useCallback을 사용해 불필요한 리렌더링을 피하고, 값비싼 컴포넌트에 전달되는 함수가 한 번만 생성되고 리렌더링 간에 동일한 참조를 유지
- useCallback은 본질적으로 함수를 위한 useMemo

- stateless component에서 리렌더링을 유발하는 입력이 있다면?

- 키 입력마다 new Date() 다시 계산 → useMemo로 이 문제 해결

```tsx
const todat = useMemo(() => new Date(), [])
```

- 그럼 isAdult의 값은 useMemo로 감싸야 할까? → 아니오!
  - 메모리 할당 외에는 계산이 필요 없는 스칼라 값이다
  - 자바스크립트 엔진과 리액트 런타임에 처리를 맡기자!
  - 컴포넌트 계산 비용(성능) vs 메모화 비용(런타임 복잡성)

### React Forget

- 리액트 컴파일러: 메모화를 자동으로 처리해 컴포넌트 렌더링 최적화 → UX + DX 개선
- 리액트 리렌더링 동작의 객체 동일성 비교를 깊은 비교 없는 시맨틱 값 비교로 변환해 성능을 향상시킴
- - React Conf 2021 - React Forget

## 지연 로딩

> 대개 자바스크립트 번들의 크기는 다른 유형의 웹 파일보다 크기 때문에 네트워크를 통해 전송할 데이터가 더 많습니다. 전송량이 제한적인 데이터 요금제를 사용하거나 인터넷 연결 속도가 더딘 사용자는 비용 증가와 페이지 로딩 시간 지연 같은 문제가 생길 수 있습니다.

- 코드 분할(code spliting)

  - import 함수로 필요할 때 자바스크립트 파일을 비동기적으로 읽어 들일 때 사용
  - 필요한 코드만 읽기 때문에 페이지 로드 시간과 데이터 사용량 줄일 수 있음

- 지연 로딩(lazy loading)
  - 페이지가 완전히 읽어 들여질 때까지 초기 실행에 필수적이지 않은 자바스크립트의 로딩을 미루기
  - 필요할 때만 코드를 읽어 들이므로 페이지 로드 시간과 데이터 사용량 줄일 수 있음

> 리액트에는 React.lazy와 Suspense를 사용한 지연 로딩이라는 훨씬 더 직관적인 해결책이 있다.
> 리액트에서 지연 로딩 → 필요한 컴포넌트만 읽어들이는 기술

- React.lazy: 필요할 때만 불러와서 사용

- lazy 함수: 읽어 들인 모듈의 프라미스를 반환하는 함수 → 컴포넌트를 동적으로 가져옴
- 동적으로 가져온 모듈은 즉시 사용 가능하지 않을 수도 있어서 모듈 자체가 아닌 프라미스 인스턴스를 반환 (우선 서버에서 다운로드해야 함)
- lazy 함수는 실제로 렌더링되기 전에는 내부의 컴포넌트를 호출하지도, 파일을 일거 들이지도 않음
- Suspense: 컴포넌트가 보이기 전까지 폴백 컴포넌트 표시

- 리액트의 Suspense는 try/catch 블록처럼 작동
- 컴포넌트 트리 어디든 지연 로드되고 비동기로 읽어 들이는 요소를 두면, 해당 트리의 상위 계층 어디에서든 Suspense 컴포넌트를 사용해 이러한 요소를 처리
- Suspense 경계가 다른 파일에서도 동작
- 전체 컴포넌트를 Suspense로 감싸고 모든 비동기 자식의 프라미스가 해결될 때까지 fallback을 렌더링
  - 사이드바를 읽는 중에는 전체 애플리케이션이 숨겨지고 로딩 중…이 보임

> 모든 컴포넌트가 준비될 때까지 기다렸다가 사용자에게 한꺼번에 사용자 인터페이스를 표시하려는 경우에는 유용할 수 있지만, 사용자는 그동안 무슨 일이 일어나는지 의문을 가질 수 있고 애플리케이션과 전혀 상호 작용하지 못하기 때문에 좋은 방법은 아님

- Suspense는 지연 로딩이 필요한 컴포넌트를 감싸는 용도로만 사용

- Suspense → 레이아웃 이동을 해결하고 직관적이고 응답성이 좋은 사용자 인터페이스 설정 가능
