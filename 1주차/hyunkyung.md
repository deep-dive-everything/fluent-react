# 1장 입문자를 위한 지식
## 1-1 리액트는 왜 필요한가요?
- 동적인 웹페이지에서 대규모 업데이트를 효율적으로 수행하기 위해서
  - 성능: 리플로우 감소
  - 신뢰성: 상태를 추적해 일관되게 유지하기 위해
  - 보안: 크로스 사이트 스크립팅(XSS)나 크로스 사이트 요청 위조(CSRF)를 방지하기 위해 html과 js를 sanitize

## 1-2 리액트 이전의 세계
1. 복잡한 사용자 인터페이스 업데이트
```html
<button id="likeButton" data-liked="false">좋아요</button>
```
```javascript
const likeButton = document.getElementById("likeButton");
likeButton.addEventListener("click", () => {
    const liked = likeButton.getAttribute("data-liked") === 'true';
    likeButton.setAttribute("data-liked", !liked);
    likeButton.textContent = liked ? "좋아요" : "좋아요!!";
})
```

위와 같이 좋아요 버튼을 누를때마다 버튼 텍스트가 바뀌는 동작을 하려고 한다고 가정해봅시다.
간단한 동작임에도 처리해야 할 작업이 많습니다. 각 줄이 어떤 일을 하는지 우리가 일일이 해석을 해야하고요.

위 코드를 리액트로 바꿔보면 차이가 더 명확해질 것입니다.

```jsx
export default function Main(){
  const [isLiked, setIsLiked] = useState(false);

  const handleClick = () => {
    setIsLiked(prev => !prev);
  }

  return <button onClick={handleClick}>
    {isLiked ? "좋아요" : "좋아요!!"}
  </button>
}
```

우리는 리액트로 개발할 때 선언적으로 코드를 작성한다고 말합니다. 코드 한줄한줄은 무엇을 하는지만 담겨있습니다.
아래처럼 말이죠. 각 코드는 자기가 할일을 할 뿐입니다. 

좋아요 버튼은 isLiked 값을 바꾸는 것 외에 다른 부분을 신경쓸 필요가 없습니다. 값의 변화에 따른 렌더링은 리액트가 알아서 해주니까요.

```jsx
export default function Main(){
    // isLiked와 setIsLiked를 선언
  const [isLiked, setIsLiked] = useState(false);
  
  const handleClick = () => {
    // isLiked 값을 바꿈
    setIsLiked(prev => !prev); 
  }
  
  return <button onClick={handleClick}>
    {isLiked ? "좋아요" : "좋아요!!"}
  </button>
}
```

반면 아래 코드는 버튼이 하는 일이 지나치게 많습니다.
좋아요 버튼의 data-liked 속성을 가져오고 이 값을 바꿔주고, textContent까지 바꿔줘야 합니다.
지금은 text만 바꾸고 있지만 바꿔야 할 ui가 많아질 수록 코드는 더 길어지고 복잡해질 것입니다.

반면 react에서는 isLiked라는 값만 저장해둔채로 주시하고 있으면 되는거죠. 코드를 예측하고 이해하기가 훨씬 쉬워졌습니다.

```javascript
const likeButton = document.getElementById("likeButton");
likeButton.addEventListener("click", () => {
    const liked = likeButton.getAttribute("data-liked") === 'true';
    likeButton.setAttribute("data-liked", !liked);
    likeButton.textContent = liked ? "좋아요" : "좋아요!!";
})
```

2. 비효율적인 처리
```html
<ul id="list-parent"></ul>

<form id="add-item-form" action="/api/add-item" method="POST">
    <input type="text" id="new-list-item-label" />
    <button type="submit">항목 추가</button>
</form>
```

```javascript
(function myApp(){
    var listItems = ["I love", "React", "and", "Typescript"];
    var parentList = document.getElementById("list-parent");
    var addForm = document.getElementById("add-item-form");
    var newListItemLabel = document.getElementById("new-list-item-label");
  
    addForm.onsubmit = function (event){
        event.preventDefault();
        listItems.push(newListItemLabel.value);
        renderListItems();
    }
  
    function renderListItems(){
        parentList.innerHTML = "";
      
        for (var i=0; i<listItems.length; i++){
            var el = document.createElement("li");
            el.textContent = listItems[i];
            parentList.appendChild(el)
        }
    }
  
    renderListItems();
})();
```
이번엔 다른 예시입니다. listItem을 입력해서 리스트를 늘려간다고 가정해봅시다.
매번 renderListItems 함수가 실행되면서 새롭게 li를 만들고 이를 parentList에 집어넣고 있습니다.

새로운 값이 추가될때마다 리스트는 모양이 달라지기 때문에 레이아웃을 다시 계산해야하는 리플로우가 일어납니다.
따라서 심각한 성능 문제를 초래할 수 있는것이죠.

React는 이를 획기적으로 해결했습니다. virtual dom이라는 것을 사용해서 이전 DOM과 새로운 DOM의 변경사항만 추적하여 한꺼번에 처리하는 것이죠.
기존의 리스트는 변경되지 않았으니 그대로 두고 새로운 아이템만 추가하여 리렌더링하여 효율적으로 처리할 수 있게 되었습니다. 

3. 기타 등등 
외에도 이벤트를 등록했으니 remove해줘야하는데 어느 시점에 해줘야할지 불분명한 점, onSubmit 같은 속성은 javascript에서 전역적으로 접근이 가능하기 때문에
추적이 어렵다는 것 여러 부작용이 있습니다.

### 1.2.1 jquery
- jquery를 사용할 때 코드의 어느 곳에서든 페이지 구조를 직접적 또는 전역적으로 수정할 수 있음(외부, 원격에서까지도)
  - 코드가 예측 불가능해지고 흩어져 구조화되지 않은 DOM 조작이 유지보수를 어렵게 함
- jquery가 인기를 잃은 이유 
  - 크기 및 로딩시간: jquery 라이브러리가 커서 읽어들이는 데 부담
  - 최신 브라우저와의 중복성: 최신 브라우저가 jquery의 기능들을 지원해주게 되며 중복된 코드가 혼란을 야기
  - 성능: 네이티브 자바스크립트 메서드가 더 빠른 경우가 많아짐
- jquery를 사용하되 예측 가능성과 재사용성을 보강한 라이브러리 등장 -> Backbond

### 1.2.2 backbone

MVC 패턴 사용(애플리케이션을 세 가지 구성요소로 나누어 작업)
- MVC 구성요소
  - 모델: 애플리케이션의 데이터와 비즈니스 규칙 담당
  - 뷰: 사용자 인터페이스. 모델이 제공한 데이터를 사용자에게 보여주고 사용자 명령을 컨트롤러로 전송
  - 컨트롤러: 모델과 뷰 사이의 인터페이스 역할
- 비즈니스 로직, 사용자 인터페이스, 사용자 입력이 코드의 여러 부분으로 분리된다는 장점이 있었음
- 단점
  - 복잡한 상호 작용 및 상태관리
    - 애플리케이션 규모가 커지면서 늘어난 컨트롤러 때문에 상태 변경과 UI의 다양한 부분에 미치는 영향을 관리하기 어려울 수도 있음
    - 화면에 표시되지 않는 뷰를 제어하는 컨트롤러가 생기기도 함
    - MVC 구성 요소 간의 경계가 명확하지 않아 다른 컨트롤러와 충돌을 일으키는 경우도 있었음
    - 리액트가 보완한 부분
      - 컴포넌트 기반 아키텍처와 가상 DOM을 사용하는 리액트는 기본적으로 UI 컴포넌트가 입력(props)을 받고 그 입력에 따라 출력(element)을 반환하는 함수와 같다고 가정하여 상태변화와 그 영향을 쉽게 파악
      - 이런 개념은 MVC 패턴을 매우 단순하게 만들었음
  - 양방향 데이터 바인딩
    - 주의깊게 관리하지 않으면 뷰가 모델과 동기화되지 않거나 모델이 뷰와 동기화되지 않는 문제가 있을 수 있음
    - 관심사 분리가 제대로 되지 않기도 함
    - 리액트가 보완한 부분
      - 단방향 데이터 흐름이라는 패턴을 사용하여 UI 업데이트의 예측 가능성을 높이고 관심사를 명확하게 분리할 수 있게 해줌
  - 강한 결합
    - 모델, 뷰 컨트롤러가 강하게 결합되어 다른 구성 요소에 영향을 주지 않고 독립적으로 하나만 변경하거나 리팩터링하기가 어려울수도 있음
    - 리액트가 보완한 부분
      - 컴포넌트 기반 모델을 통해 더 모듈화되고 분리된 접근 방식 장려함. 필요한 구성 요소를 UI 표현의 가까운 곳에 둘 수 있음

Backbone의 장점
- MVC 패턴을 잘 다룰 수 있는 편리한 API 제공
- 확장 가능하여 개발자가 코드를 격리해 테스트할 수 있었음

Backbone의 단점
- 장황한 코드 및 보일러플레이트 코드
- 양방향 데이터 바인딩 부족: 기본으로 제공하지 않아서 개발자가 직접 작성하거나 플러그인 사용
- 이벤트 중심 아키텍쳐: 모델 업데이트 이후 발생한 이벤트 관리가 불가능하여 애플리케이션에 어떤 영향을 미치는지 파악하기 어렵고 유지보수 힘들었음
- 조합성 부족: 뷰를 쉽게 중첩할 수 있는 기능이 내장되지 않아 복잡한 사용자 인터페이스를 구성하기 어려움

### 1.2.3 knockout
MVVM 패턴 사용
- MVVM 구성 요소
  - 모델
    - 애플리케이션의 데이터 및 비즈니스 로직을 나타냄
    - 데이터 검색, 저장, 처리 담당
    - 뷰 및 뷰 모델을 인식하지 못함
  - 뷰
    - 애플리케이션의 UI 표시
    - 수동적이며 애플리케이션 로직을 포함하지 않음
    - 대신 데이터 바인딩 매커니즘을 통해 자동으로 변경 사항을 반영해 선언적으로 뷰 모델에 바인딩
  - 뷰 모델
    - 모델과 뷰 사이의 다리 역할을 함
    - 뷰에 바인딩할 데이터와 명령 제공
    - 명령 패턴을 통해 사용자 입력 처리
    - 모델의 데이터를 뷰에서 쉽게 표시할 수 있는 형식으로 변환
    - 뷰 모델은 어떤 뷰가 자신을 사용하는지 인식하지 못함
- MVVM 패턴의 장점
  - 테스트 가능성
    - 뷰에서 뷰 모델을 분리하면 UI를 포함하지 않고도 프레젠테이션 로직에 대한 단위 테스트를 쉽게 작성할 수 있음
  - 재사용성
    - 뷰 모델은 여러 뷰 또는 플랫폼에서 재사용가능
  - 유지 보수성
    - 명확한 분리를 통해 코드를 관리, 확장, 리팩터링하기가 더 쉬워짐
  - 데이터 바인딩
    - UI 업데이트에 필요한 보일러 플레이트 코드의 양을 줄임
- MVC와 차이점
  - 결합과 바인딩
    - 모델과 뷰 사이에 컨트롤러가 없는 경우 데이터 소유권이 더 명확하고 사용자에게 가까이 있음
    - 리액트는 단방향 데이터 흐름을 통해 MVVM을 개선했는데, 데이터 소유권이 더욱 제한되어 상태가 필요한 특정 컴포넌트가 상태를 소유
- knockout의 단점
  - 옵저버블을 명시적으로 구독하고 변경에 따라 업데이트하기 위해 많은 보일러 플레이트 코드가 필요했음
  - 뷰 모델이 거대해지고 복잡해지면서 리팩터링과 코드 최적화가 불확실해짐

### 1.2.4 앵귤러 JS
앵귤러JS가 리액트에 앞서 구축해놓은 토대
- 양방향 데이터 바인딩
  - 모델(기반 데이터)이 변경되면 뷰(UI)도 변경 사항을 반영하도록 자동으로 업데이트, 그 반대도 마찬가지
  - react는 setState에 의해서만 데이터가 변경되므로 단방향 데이터 바인딩 사용
- 모듈식 아키텍처
  - 애플리케이션의 구성 요소를 논리적으로 분리하여 사용
  - 컴포넌트 모델의 선구자
- 의존성 주입
  - 객체가 의존성을 직접 만드는 대신 전달받는 디자인 패턴

앵귤러JS 트레이드오프
- 성능: 변경사항 감지를 위한 핵심 기능인 앵귤러 JS의 다이제스트 주기는 대규모 애플리케이션에서 업데이트 지연과 사용자 인터페이스 응답성 저하의 원인이 되었음
- 복잡성: 지시자, 컨트롤러, 서비스, 의존성 주입, 팩토리 등 새로운 개념 때문에 러닝 커브가 높아짐
- 앵귤러 2+로의 마이그레이션 문제: 1.x와 하위 호환되지 않아 코드를 재작성해야했음
- 복잡한 템플릿 문법: 복잡한 자바스크립트 표현식을 허용하여 HTML안에 프레젠테이션과 비즈니스 로직이 뒤섞이게 됨
- 타입 안정성 부재: 타입스크립트 같은 정적 유형 검사기에서 작동하지 않음

## 1.3 리액트 등장
- 컴포넌트 기반 아키텍쳐 -> 재사용 가능한 컴포넌트를 조합하자
- 단방향 데이터 바인딩을 통해 성능 문제를 개선하고 뷰와 모델을 훨씬 쉽게 동기화시킴

### 1.3.1 리액트의 핵심 가치
**선언적 코드와 명령형 코드**
- 무엇을 완료하고 싶은지 기술하면 어떻게 할지는 리액트가 다룸

**가상 DOM**
- 가상 DOM을 사용해 컴포넌트의 변경 사항을 추적하고 필요한 때만 컴포넌트를 다시 렌더링
- 가상 DOM은 실제 DOM 트리를 가볍게 표현한 것으로 UI 요소의 구조와 속성을 나타내는 평범한 자바스크립트 객체
- 리액트는 실제 DOM 트리와 일치하도록 가상 DOM을 생성하고 업데이트하며, 가상 DOM에서 발생한 모든 변경사항은 재조정이라는 과정을 통해 실제 DOM에 적용 
- 가상 DOM이 어떻게 작동하는지 살펴보겠습니다.
```
{
  $$typeof: Symbol.for('react.element'),
  type: 'div',
  props: {},
  children: [
    {
      $$typeof: Symbol.for('react.element'),
      type: 'button',
      props: { onClick: handleLike },
      children: ['좋아요']
    },
    {
      $$typeof: Symbol.for('react.element'),
      type: 'p',
      props: { },
      children: [0, '명']
    }, 
  ]
}
```

사용자가 좋아요 버튼을 클릭하면 handleLike 함수가 호출되어 likes 상태 변수가 업데이트 됩니다.
그러면 리액트는 업데이트된 상태를 반영하는 새로운 가상 DOM 트리를 생성합니다.

```
{
  $$typeof: Symbol.for('react.element'),
  type: 'div',
  props: {},
  children: [
    {
      $$typeof: Symbol.for('react.element'),
      type: 'button',
      props: { onClick: handleLike },
      children: ['좋아요']
    },
    {
      $$typeof: Symbol.for('react.element'),
      type: 'p',
      props: { },
      children: [1, '명']
    }, 
  ]
}
```
새로운 가상 DOM 트리를 계산한 후 리액트는 재조정이라는 프로세스를 수행해 새 트리와 이전 트리의 차이점을 파악합니다.
재조정은 이전 가상 DOM 트리와 새 가상 DOM 트리를 비교해 실제 DOM의 어느 부분을 업데이트해야하는지 결정하는 과정입니다.

리액트는 이전 가상트리와 새 가상트리를 비교해 프롭이 변경되었거나 상태가 변경되었거나 둘다 변경되었는지를 확인하여 업데이트가 필요함으로 표시합니다.
이후 최소한의 업데이트 동작을 계산한뒤 최종적으로 가상 DOM에 적용된 변경 사항을 반영하도록 실제 DOM을 업데이트합니다.

**컴포넌트 모델**
- 리액트는 애플리케이션을 작은 조각으로 나누고 이를 커다란 트리에 애플리케이션을 구성하는 컴포넌트 단위로 생각하기를 적극 권장
- 컴포넌트 모델의 장점
  - 유지보수용이: 똑같은 것은 어디서나 재사용하도록 장려하기 때문에 문제가 발생한 경우 한 곳만 수정해도 관련된 곳이 모두 수정됨
  - 컴포넌트를 식별하여 최적화 및 성능 작업을 쉽게 수행: 키잉이라는 컴포넌트마다 키를 매핑해놓고 메모화, 일괄처리 등의 최적화 + 추적을 용이하게 합니다.
  - 관심사 분리 및 응집도 강화

**불변상태**
- 리액트의 설계 철학을 애플리케이션 상태를 불변하는 값의 집합으로 기술하는 패러다임을 강조
- 각각의 상태 업데이트는 새로운 독립 스냅숏과 메모리 참조로 취급됨
- 불변성을 강제함으로써 UI 컴포넌트가 특정 시점의 특정 상태를 반영하도록 보장
  - 상태가 변경되면 원래 있던 상태를 직접 변경하는 대신 새로운 상태를 표현하는 새 객체를 반환
- 불변성이 보장되므로 상태 관리 예측이 쉬워지고 복잡한 상태 변환을 할 때 애플리케이션 성능이 개선됨

### 1.3.3 플럭스 아키텍처
- 플럭스는 클라이언트 측 웹 애플리케이션 구축을 위한 아키텍처 디자인 패턴이며, 페이스북에서 발표
- 단방향 데이터 흐름을 강조해 애플리케이션 데이터의 흐름을 더욱 예측 가능하게 만듦
- 플럭스 아키텍처의 핵심 개념
  - 액션
    - 새 데이터와 액션의 종류를 식별하는 속성을 포함하는 단순한 객체
    - 사용자 상호 작용, 서버 응답, 양식 입력 등 시스템에 대한 내외부 입력을 표현
```
// 액션 객체 예시
{
    type: 'ADD_TODO',
    text: '플럭스 아키텍처 학습'
}
```
  - 디스패처
    - 플럭스 아키텍처의 중심
    - 액션을 받아서 애플리케이션에 등록된 스토어로 보냄
    - 모든 스토어는 디스패처에 스토어 자신과 콜백을 등록해 두는데, 이 콜백 목록을 관리하는 것도 디스패처
    - 액션을 디스패칭하면 등록된 모든 콜백으로 해당 액션을 전송
```
// 액션 디스패칭의 예시
Dispatcher.dispatch(action)
```
  - 스토어
    - 애플리케이션 상태와 로직을 포함
    - MVC 아키텍처의 모델과 다소 유사하지만 스토어는 다수 객체의 상태를 관리
    - 스토어 자신을 디스패처에 등록하고 액션을 처리하는 콜백도 제공
    - 스토어 상태가 업데이트되면 변경 이벤트를 발생시켜 뷰에 변경된 사항을 알림
```js
// 스토어의 예시
class TodoStore extends EventEmitter {
    constructor(){
        super();
        this.todos = [];
    }
  
    handleAction(action){
        swtich (action.type)
        {
        case "ADD_TODO":
            this.todos.push(action.text);
            this.emit("change");
            break;
        default:
            //아무 동작 없음
      }
    }
}   
```
  - 뷰
    - 리액트 컴포넌트
    - 스토어에서 변경 이벤트를 받으며, 의존하는 데이터가 변경되면 스스로 업데이트

### 1.3.4 플러스 아키텍처의 장점
- 단일 정보 출처
  - 플럭스에서는 애플리케이션의 상태에 대한 단일 정보 출처(single source of truth)가 스토어에 저장되는 것이 중요
  - 중앙 집중식 관리로 애플리케이션의 동작을 더 예측하기 쉽고 이해하기 쉽게 만듦
- 테스트 가능성
- 관심사 분리

## 1.4 그래서 리액트가 왜 필요한가요?
- 리액트는 개발자들이 더 예측 가능하고 신뢰성 있는 방향으로 사용자 인터페이스를 작성할 수 있게 하고, 우리가 화면에 나타내고자 하는 바를 선언적으로 표현할 수 있게 함
- 화면에 어떻게 나타날지 신경쓰지 않아도 리액트가 알아서 효율적인 방식으로 DOM에 점진적인 업데이트 수행
- 컴포넌트 단위로 생각하도록 장려해 관심사를 분리하고 코드를 더 쉽게 재사용하도록 도와줌
- 리액트 커뮤니티와 라이브러리 지원도 활발하고 방대
- 플랫폼에 구애받지 않으므로 웹뿐만 아니라 다양한 플랫폼에서도 애플리케이션을 작성하는 데 사용 가능

# 2장 JSX
- JSX: 자바스크립트 확장구문

## 2.1 자바스크립트 XML?
- AJAX: 비동기적 자바스크립트와 XML
  - AJAX: 페이지를 벗어나지 않은 채 비동기적으로 업데이트되는 대화형 웹페이지를 만드는 새로운 방식
  - XMLHTTPRequest 같은 도구를 사용하면 HTTP를 통해 비동기 요청을 할 수 있음 -> 일반적으로 XML로 응답했으나 오늘날에는 JSON이 더 일반적
- JSX는 개발자가 자바스크립트 코드 내에서 HTML과 유사한 코드를 작성할 수 있게 해줌
  - 컴파일러나 트랜스파일러에 의해 일반 자바스크립트 코드로 변환됨

## 2.2 JSX의 장점
- 더 쉬운 읽기 및 쓰기
- 향상된 보안
  - < 나 > 같은 문자를 이스케이프 처리하지 않아도 됨
  - sanitization을 알아서 해줌
- 강력한 타이핑
  - 강력한 타이핑을 지원하여 오류가 발생하기 전에 잡아낼 수 있음
- 컴포넌트 기반 아키텍처
  - JSX는 컴포넌트 기반 아키텍처를 지원하므로 코드를 재사용하기 쉽고 유지보수하기 쉬움
- 광범위한 사용
  - 리액트뿐만 아니라 다양한 라이브러리와 프레임워크에서도 사용 가능

## 2.3 JSX의 약점
- 학습 곡선 가중
  - JSX에 익숙하지 않은 개발자에게는 학습 곡선이 가파를 수 있음
- 전용 도구 필요
  - 컴파일을 위해 Babel과 같은 전용 도구가 필요
- 관심사 혼합
  - JSX는 HTML과 자바스크립트를 혼합하므로 관심사가 혼합되어 있을 수 있음
- 자바스크립트 호환성 부족
  - JSX는 인라인 표현식을 지원하지만 인라인 블록은 지원하지 않음
  - switch나 if 블록은 가질 수 없음

## 2.4 내부 동작
```js
const a = 1;
let b = 2;

console.log(a+b);
```

위 코드는 텍스트일뿐이고 컴파일러를 통해 코드를 컴파일하여 실행가능한 코드로 변환해야합니다.

컴파일러는 3단계 과정을 거칩니다.

1. 토큰화
- 문자열을 의미 있는 토큰으로 분해
2. 구문분석
- 토큰을 가져와 코드의 구조를 나타내는 구문 트리로 변환
3. 코드 생성
- 컴파일러가 추상 구문 트리에서 기계어를 생성하는 과정

컴파일러 종류에는 여러가지가 있습니다.

- 네이티브 컴파일러: 대상 플랫폼의 프로세서에서 직접 실행할 수 있는 기계어 생성 -> 독립 실행할 애플리케이션이나 시스템수준의 소프트웨어
- 크로스 컴파일러: 컴파일러가 실행 중인 플랫폼과 다른 플랫폼용 기계어 생성 -> 임베디드 시스템 계열이나 특수 하드웨어 대상
- JIT 컴파일러: 실행 중에 코드를 컴파일 -> 자바 가상 머신 같은 가상 머신에서 일반적으로 사용됨
- 인터프리터: 컴파일하지 않고 소스코드를 직접 실행 -> 일반적으로 컴파일러보다 속도가 느리지만 유연성과 사용 편의성이 우수

웹 브라우저를 비롯한 최신 환경에서는 JIT 컴파일러를 많이 사용합니다. 자바스크립트 소스코드가 먼저 바이트코드 같은 중간 표현으로 변환됩니다.
그런 다음 프로그램이 실행될 때 이 바이트코드를 기계어로 동적 컴파일합니다.

런타임은 일반적으로 엔진과 연동해 특정 환경에 맞는 콘텍스트 헬퍼와 기능을 더 많이 제공합니다. 가장 인기 있는 자바스크립트 런타임은 구글 크롬 같은 웹 브라우저입니다.
크롬 웹 브라우저는 엔진과 연동하는 크로미움 런타임을 제공하고 서버 측에서는 v8 엔진을 사용하는 Node.js 런타임을 사용합니다.

### 2.4.2 JSX로 자바스크립트 구문 확장하기
- JSX를 위한 맞춤형 특수 엔진을 만드는 것보다는 새로운 구문을 처리하도록 Babel과 같은 트랜스파일러를 사용하는 것이 더 효율적
- 트랜스파일은 한 언어로 작성된 소스 코드를 추상화 수준이 비슷한 다른 언어로 변환하는 과정

## 2.5 JSX 프라그마
- JSX 프라그마는 모두 <로 시작
- 자바스크립트 엔진은 이 문자를 발견하면 SyntaxError를 발생 -> JSX에서는 이런 JSX 프라그마가 함수 호출로 변환될 수 있음
- 자바스크립트에서 볼 수 있는 지시어의 예로는 'use strict'가 있음
- 구문 분석기가 < 프라그마를 만날 때 이를 함수 호출로 변환하도록 지시하는 것이 JSX 프라그마 -> React.createElement 또는 __jsxs가 기본값으로 정해짐

```js
function pragma(tag, props, ...children)
```

```jsx
<MyComponent prop="속성값">콘텐츠</MyComponent>
```

- 위 코드는 아래와 같은 자바스크립트 코드가 됨

```js
React.createElement(MyComponent, {prop: "속성값"}, "콘텐츠")
```

## 2.6 표현식
- JSX의 강력한 기능 하나는 엘리먼트 트리 내부에서 코드를 실행하는 것
- JSX는 자바스크립트 표현식을 중괄호로 감싸서 표현할 수 있음
- 중괄호 안에는 자바스크립트 표현식을 넣을 수 있음

```jsx
const name = "리액트";
const element = <h1>Hello, {name}</h1>;
```