# 1장-입문자를 위한 지식

## 1.1 리액트는 왜 필요한가요?

- 웹이 발전하고 기능이 다양해지면서 사용자 경험에 대한 관심도 커짐
- 하지만 즉각적인 업데이트(렌더링)를 대규모로 수행하는 것은 아래와 같은 어려움이 존재
    - 성능
        - 웹 페이지를 업데이트하면 보통 브라우저가 페이지의 레이아웃을 재계산하고(reflow) 그리는 작업(repaint)를 수행하기 때문에 성능 병목 현상이 자주 발생
    - 신뢰성
        - 풍부한 웹 경험 전반에서 상태를 추적해 일관되게 유지하기가 어려워졌음
            
            → 상태를 여러 곳에서 추적해 모든 곳에서 일관되게 유지해야 했기 때문
            
    - 보안
        - 크로스 사이트 스크립팅(XSS) 및 크로스 사이트 요청 위조(CSRF) 같은 악용을 방지하기 위해 페이지에 삽입하는 HTML과 자바스크립트를 모두 소독해야만 했음
            
            (소독 : 사용자 입력 등 데이터에서 문제가 될 만한 부분을 제거하는 것)
            

## 1.2 리액트 이전의 세계

- 리액트가 없던 시절 개발자들은 애플리케이션이 빠른 느낌을 주면서 규모가 큰 동시에 안전하고 안정적으로 작동하는 방법을 찾아야 했음
- 예시 -  사용자가 버튼을 클릭하면 어떤 동작을 수행하고 그 상태를 반영해 사용자 인터페이스를 업데이트 해야하는 상황(좋아요 버튼)
    - 여기서 고려해야할 인터페이스 상태는 최소 네 가지
        - 클릭 전
        - 클릭했지만 대기 중
        - 클릭 후 성공
        - 클릭 후 실패
    - 개발자는 사용자 인터페이스를 업데이트해 상태를 반영해야 함
    - 사용자 인터페이스 업데이트 단계
        - 호스트 환경(주로 브라우저)에서 `document.querySelector` 또는 `document.getElementById` 같은 엘리먼트 탐색 API를 사용하여 버튼 찾기
        - 버튼에 이벤트 리스너를 추가해 클릭 이벤트 추적하기
        - 이벤트에 반응해 상태 업데이트하기
        - 페이지에서 벗어날 때는 버튼의 이벤트 리스너를 제거하고 모든 상태를 정리하기
    - 완성 코드
        
        ```html
        <button id="likeButton" data-pending="false" data-liked="false" data-failed="false">
          좋아요
        </button>
        ```
        
        ```jsx
        const likeButton = document.getElementById('likeButton');
        likeButton.addEventListener('click', () => {
        	const liked = likeButton.getAttribute('data-liked') === 'true';
          
         	likeButton.setAttribute('data-pending', 'true');
          likeButton.setAttribute('disabled', 'disabled');
          // 네트워크 요청이 처리 중일 땐 버튼을 비활성화 처리
          // 짧은 시간 내 여러 요청하는 경우를 방지하기 위함
          
          // 네트워크 통신
          fetch('/like', {
          	method: 'POST',
            body: JSON.stringify({ liked:!liked }),
          }).then(() => {
          	likeButton.setAttribute('data-liked', !liked);
            likeButton.textContent = liked ? '좋아요' : '좋아요!!';
            likeButton.setAttribute('disabled', null);
          }).catch(() => {
          	likeButton.setAttribute('data-failed', 'true');
            likeButton.textContent = '실패';
          }).finally(() => {
          	likeButton.setAttribute('data-pending', 'false');
          });
        });
        
        ```
        
- 버튼 관련 작은 기능이지만 브라우저에서 버튼을 찾고, 이벤트 리스너를 추가하고 버튼의 텍스트 콘텐츠를 업데이트하고, 많은 에지케이스를 일일이 고려해야함
    
    → 상호작용 해야 하는 버튼이 많은 경우 혹은 버튼이 엄청 많은 경우엔 어떻게 처리 해야 할지?
    
- CSS와 HTML, 자바스크립트만 사용해서 수백만 명의 사용자를 대상으로 최신 웹 애플리케이션을 구축하기 위해서는 높은 수준의 추상화가 필요
- 자바스크립트를 사용하면 DOM API에 접근이 가능하지만 사용자 디바이스의 DOM으로 사용하는 브라우저, 네트워크 조건, 운영체제 등을 알 수 없음
    - 모든 요소에 유연하게 대응 가능한 코드를 작성해야함
- 예시 - 목록에 새 항목을 추가하는 자바스크립트 코드(초기 웹 애플리케이션과 비슷하게 작성)
    
    ```jsx
    (function myApp(){
    	var listItems = ['I love', 'React', 'and', 'TypeScript'];
      var parentList = document.getElementById('list-parent');
      var addForm = document.getElementById('add-item-form');
      var newListItemLabel = document.getElementById('new-list-item-label');
      
      addForm.onsubmit = function(event){
      	event.preventDefault();
        listItems.push(newListItemLabel.value);
        renderListItems();
      };
      
      function renderListItems(){
      	parentList.innerHTML = '';
        for(var i = 0; i < listItems.length; i++){
        var el = document.createElement('li');
        el.textContent = listItems[i];
        parentList.appendChild(el);
        }
      }
      renderListItems();
    })();
    ```
    
- 문제점(시간이 지나면서 문제가 생기는 이유)
    - 오류가 쉽게 생김
        - addForm의 onsubmit 속성은 다른 클라이언트 측 자바스크립트에서 손쉽게 접근, 변형이 가능함
        - addEventListener를 대신 사용할 수 있지만 이 경우 고려해야할 게 더 많아짐
            - removeEventListener로 언제 어디에서 정리..?
            - 이벤트리스너가 계속 누적된다면..?
            - 이벤트 위임은 어떻게 사용..?
    - 예측이 불가능함
        - 예시코드의 목록 항목은 자바스크립트 배열에 보관하지만 앱을 완성하기 위애 DOM의 기존 엘리먼트(e.g. id=’list-parent’ 엘리먼트)에 의존함
        - 자바스크립트와 HTML의 상호의존성 때문에 다양한 고려 사항 존재
            - 실수로 id가 동일한 엘리먼트가 여러 개 있다면..?
            - 만약 엘리먼트가 존재하지 않는다면..?
            - 엘리먼트가 ul이 아니라면? 목록항목(li 엘리먼트)을 ul아 아닌 부모에 추가할 수 있나..?
            - id 대신 클래스를 사용했다면..?
        - 다뤄야할 요소가 자바스크립트, HTML 양쪽에 존재할 경우 신뢰하기 어려워짐
            - **엘리먼트는 항상 클라이언트 측 자바스크립트에 의해서만 DOM에 추가되고 제거될 것. 특정 엘리먼트의 존재 여부에 의존하게 된다면 계속 업데이트해야하는 사용자 인터페이스 동작의 안정성을 보장하기 어려움**
            - **리액트는 함수형 프로그래밍에서 영감을 얻어 부작용을 의도적으로 드러내고 격리하는 방식으로 문제를 해결했음**
    - 비효율적임
        - renderListItems는 목록 항목을 순차적으로 화면에 렌더링. 레이아웃 이동이나 reflow 발생시 계산 비용이 비싸짐
        - 대규모 웹 애플리케이션은 전 세계 수백만 사용자가 사용할 수 있도록 설계되어야함(저전력 기기를 사용하는 사용자도 존재)
        - 목록의 각 항목을 순차적으로 DOM에 업데이트하는 방법 대신 일괄처리해 한꺼번에 DOM에 적용하는 방법이 좋음.
- 예시에서 말한 여러 문제는 리액트와 같은 추상화 도구가 등장하기 이전부터 많은 개발자들에게 골칫거리였음
- 업계의 표준화된 방법이 없는 상태에서 유지보수가 용이하고 재사용과 예측이 가능한 방식으로 대규모 코드를 꾸리는 것은 많은 사람들의 고민이었음
    
    → 안정적이고 확장 가능한 사용자 인터페이스를 만들어야한다는 인식이 확산됨에 따라 Backbone, Knockout, 앵귤러JS, jQuery와 같은 여러 자바스크립트 기반 솔루션이 등장하게됨
    

### 1.2.1 jQuery

- ‘좋아요’ 버튼 jQuery로 구현하기
    
    ```html
    <button id="likeButton">
      좋아요
    </button>
    ```
    
    ```jsx
    $('#likeButton').on('click', function(){
      $(this).prop('disabled', true);
      fetch('/like', {
        method: 'POST',
        body: JSON.stringify({ liked: this.text() === '좋아요' }),
      }).then(() => {
        this.text(this.text() === '좋아요' ? '좋아요!!' : '좋아요');
      }).catch(() => {
        this.text('실패');
      }).finally(() => {
        this.prop('disabled', false)
      });
    });
    ```
    
    - 사용자 인터페이스에서 데이터를 바인딩하고, 이를 사용해 페이지를 벗어나지 않은 채 사용자 인터페이스를 업데이트함
        
        **→ jQuery는 사용자 인터페이스 자체를 직접 조작 가능**
        
- 사용자 인터페이스를 직접 조작하면 어떤 문제가 생길까?
    - 코드의 어느 곳에서든 페이지 구조를 직접적(혹은 전역적)으로 수정이 가능하므로 사이드 이펙트의 발생 가능성 또한 증가
    - 이처럼 구조화 되지 않은 DOM 조작은 유지보수, 디버깅을 어렵게 함
- 최신 프레임워크는 직접적인 DOM 조작 없이 UI를 업데이트하는 구조적이고 예측 가능한 방식으로 위와 같은 문제를 해결했음

### jQuery가 인기를 잃은 이유

- 크기 및 로딩 시간
    - 전체 jQuery 라이브러리를 웹 프로젝트에 통합하면 읽어들여야 할 파일 크기가 늘어나므로 로딩 시간 단축을 목표로 하는 웹사이트의 경우 적합하지 않음
    - 리액트 등장 전 주로 jQuery나 Mootools 같은 라이브러리용  설정 도구를 제공해 사용자가 원하는 기능을 골라서 사용했음 → 개발자가 내려야 하는 결정과 전반적인 개발 워크플로의 복잡성이 증가
- 최신 브라우저와의 중복성
    - jQuery가 처음 등장했을 때는 각 브라우저의 동작에 일치하지 않는 부분을 다뤄 개발자들이 통합된 방식으로 요소를 선택하고 수정하게 해주었음
    - 그러나 브라우저의 발전에 따라 위와 같은 문제점들이 개선되었고 jQuery의 사용이 불필요해짐
        - e.g. 일관된 DOM 조작(jQuery가 제공하는 $ 선택자 API는 document.querySelector로 대체 가능)
        - 참고
            
            [(jQuery) 제이쿼리 선택자(jQuery selector)](https://www.zerocho.com/category/jQuery/post/57a9a371e4bc011500624ba3)
            
- 성능 고려 사항
    - 브라우저가 발전함에 따라 네티이브 자바스크립트 메서드 또한 개선되어 jQuery가 제공하는 메서드 성능을 추월하였음
- jQuery는 여러 단점에도 불구하고 당시 DOM과 상호 작용하는 방식에 있어 매우 혁신적이었음
    
    → jQuery를 사용하되 예측 가능성과 재사용성을 보강한 라이브러리가 등장(Backbone 등)
    

### 1.2.2 Backnbone

- 2010년대 초에 개발됨
- 리액트 등장 전 브라우저와 자바스크립트 간의 상태 불일치, 코드 재사용, 테스트 가능성 등을 처음으로 해결한 방법
- 전통적인 MVC(모델-뷰-컨트롤러) 패턴을 자체 해석

### MVC 패턴

![image](https://github.com/user-attachments/assets/451d851f-2904-409f-a593-1a7bb398de9e)

- 소프트웨어 어플리케이션을 모델, 뷰, 컨트롤러 세 가지 요소로 나누고 정보의 내부 표현과 해당 정보가 사용자에게 표시되거나 수용되는 방식을 요소 별로 분리하는 디자인 철학
    - 모델
        - 애플리케이션의 데이터와 비즈니스 규칙을 담당
        - 모델은 뷰 및 컨트롤러를 인식하지 못하므로 비즈니스 로직이 사용자 인터페이스에서 분리되어있음
    - 뷰
        - 애플리케이션의 사용자 인터페이스를 뜻함
        - 모델이 제공한 데이터를 사용자에게 표시. 사용자 명령을 컨트롤러로 전송함
        - 모델이 데이터를 제공할 때까지 기다리며, 데이터를 직접 가져오거나 저장하지 않음.
        - 사용자 상호 작용을 자체적으로 처리하지 않고 컨트롤러에게 위임
    - 컨트롤러
        - 모델과 뷰 사이의 인터페이스 역할
        - 뷰에서 사용자 입력을 받아 표시할 결과를 뷰에 반환함
- MVC 패턴의 장점
    - 비즈니스 로직, 사용자 인터페이스, 사용자 입력이 코드의 여러 부분으로 분리됨
    → 애플리케이션이 더 모듈화되고 유지보수, 확장, 테스트가 더욱 수월해짐
- 웹 애플리케이션이 발전하고 사용자가 인터랙티브한 동적 인터페이스 거는 기대가 커지면서 전통적인 MVC 패턴의 한계가 두드러짐
- MVC의 부족한 부분과 리액트가 문제를 해결하는 방법
    - 복잡한 상호 작용 및 상태 관리
        - 애플리케이션 규모가 커지면서 늘어난 컨트롤러 때문에 상태 변경과 UI의 다양한 부분에 미치는 영향을 관리하기 어려울 수 있음
        - 컴포넌트 기반 아키텍처와 가상 DOM을 사용하는 리액트는 기본적으로 UI 컴포넌트가 입력(prop)받고 그 입력에 따라 출력(element)을 반환하는 함수와 같다고 가정해 상태 변화와 그 영향을 쉽게 파악 가능 → MVC 패턴을 매우 단순하게 만듦
    - 양방향 데이터 바인딩
        - 일부 MVC 프레임워크는 양방향 데이터 바인딩을 사용하므로 사이드 이펙트가 생길 확률이 커짐. MVC 패턴의 특징인 관심사 분리는 강제성이 없을 때 약점이 되기도 함
        - 리액트는 단방향 데이터 흐름이라는 패턴을 활용. 또한 리액트 컴파일러 같은 시스템을 통해단방향 데이터 흐름의 우선순위를 정하고 강제함
        → UI 업데이트의 예측 가능성을 높이고 관심사를 더 명확하게 분리할 수 있게 해 주어 빠르게 성장하는 소프트웨어 조직에 유리함
    - 강한 결합
        - 일부 MVC 구현에서는 모델, 뷰, 컨트롤러가 강하게 결합되어 다른 구성요소에 영향을 주지 않고 독립적으로 하나만 변경하거나 리팩터링하기 어려울 수 있음
        - 리액트는 컴포넌트 기반 모델을 통해 더 모듈화되고 분리된 접근 방식을 장려함

### Backbone

- Backbone은 모델, 뷰와  함께 작업할 수 있는 편리한 API를 제공하고, 모델과 뷰를 연결하는 방법을 제시함
- 또한 확장이 가능하고, 개발자가 코드를 격리해 테스트하는 게 가능했음
- Backbone의 단점
    - 장황한 코드 및 보일러플레이트 코드
        - 개발자가 작성해야하는 보일러플레이트 코드의 양이 큼.
    - 양방향 데이터 바인딩 부족
        - 양방향 데이터 바인딩 기능을 기본적으로 제공하지 않음
        → 데이터 변경시 DOM이 자동으로 업데이트 되지 않았음 이를 위해 개발자가 직접 기능을 구현하거나 플로그인을 사용했어야만했음
    - 이벤트 중심 아키텍처
        - 모델 데이터를 업데이트하면 전체 애플리케이션에서 수 많은 이벤트가 발생할 수 있음. 이런 이벤트들이 관리가 불가능한 문제를 해결하기 위해 개발자가 데이터 업데이트의 파급 효과를 막는 이벤트 관리 방법을 주의 깊게 사용했어야했음
    - 조합성 부족
        - 뷰를 쉽게 중첩할 수 있는 기능이 내장되지 않았기 때문에 복잡한 사용자 인터페이스를 구성하기 어려움

### 1.2.3 Knockout

- 옵저버블과 바인딩을 작성하는 방법을 제공하는 라이브러리로 2010년대 초에 개발됨(상태가 변경될 때마다 옵저버블과 바인딩을 활용해 의존성을 추적함)
    - 옵저버블은 데이터의 출처. 바인딩은 해당 데이터를 소비하고 렌더링하는 사용자 인터페이스를 뜻함
- 최초의 반응형 자바스크립트 라이브러리 중 하나(화면 크기에 따라 표현을 달리하는 반응형 웹의 반응형과는 다름)
- MVC 패턴에서 더 진화한 형태인 MVVM 패턴(모델-뷰-뷰-모델)을 사용

### MVVM 패턴

![image](https://github.com/user-attachments/assets/063f7850-d17d-4a45-b89b-113b5e7e6c68)

- 데이터 바인딩이 중요해진 최신 UI 개발 플랫폼에 맞춰 기본의 MVC패턴을 발전시킨 것
    - 모델
        - 애플리케이션의 데이터 및 비즈니스 로직을 나타냄
        - 데이터 검색, 저장, 처리를 담당
        - 일반적으로 데이터베이스, 서비스, 다른 데이터 출처와 통신하고 작업
        - 뷰 및 뷰 모델을 인식하지 못함
    - 뷰
        - 애플리케이션의 UI를 표시
        - 사용자에게 정보를 표시하고 사용자 입력을 받음
        - 뷰는 수동적이며 애플리케이션 로직을 포함하지 않음(대신 데이터 바인딩 메커니즘을 통해 자동으로 변경 사항을 반영해 선언적으로 뷰 모델에 바인딩함)
    - 뷰 모델
        - 모델과 뷰 사이의 다리 역할
        - 뷰에 바인딩할 데이터와 명령을 제공함
        (데이터는 대부분 표시할 수 있는 형식으로 되어있음)
        - 명령 패턴을 통해 사용자 입력을 처리함
        - 프레젠테이션 로직을 포함하고 모델의 데이터를 뷰에서 쉽게 표시할 수 있는 형식으로 변환함
        - 분리된 아키텍처를 위해 뷰 모델은 어떤 뷰가 자신을 사용하지는 인식할 수 없음
- MVVM 패턴의 장점(관심사 분리 관련 장점)
    - 테스트 가능성
        - 뷰에서 뷰 모델을 분리하면 UI를 포함하지 않고도 프레젠테이션 로직에 대한 단위 테스트를 쉽게 작성 가능함
    - 재사용성
        - 뷰 모델은 여러 뷰 또는 플랫폼에서 재사용 가능
    - 유지 보수성
        - 명확한 분리를 통해 코드를 관리, 확장, 리팩터링하기가 더 용이해짐
    - 데이터 바인딩
        - 데이터 바인딩을 지원하는 플랫폼에서 탁월한 성능을 발취해 UI 업데이트에 필요한 보일러플레이트 코드의 양을 줄여줌
- MVC와 MVVM 패턴 비교
    
    
    | 기준     | MVC                                                 | MVVM                                                                       |
    | -------- | --------------------------------------------------- | -------------------------------------------------------------------------- |
    | 주요 목적 | 사용자 인터페이스와 로직을 분리하는 웹 애플리케이션 용 | 데스크톱이나 SPA처럼 양방향 데이터 바인딩이 필요한 UI가 많은 애플리케이션에 적합  |
    | 구성 요소 | 모델-뷰-컨트롤러                                     | 모델-뷰-뷰모델                                                              |
    | 데이터 흐름 | 사용자 입력은 컨트롤러에서 관리됨                    | 뷰는 뷰 모델에 직접 바인딩됨                                                 |
    |            | 컨트롤러는 모델을 업데이트 후 뷰를 업데이트           | 뷰의 변경사항은 뷰 모델에 자동 반영(그 반대의 경우도 마찬가지)                  |
    | 디커플링   | 뷰는 종종 컨트롤러와 강하게 결합됨                    | 뷰모델이 사용하는 특정 뷰를 알지 못하므로 느슨하게 결합됨                       |
    | 사용자 상호 작용 | 컨트롤러에서 처리                              | 뷰모델의 데이터 바인딩 및 명령을 통해 처리됨                                    |
    | 플랫폼 적합성 | 웹애플리케이션 개발(e.g. 루비온레일즈, 장고, ASP.NET MVC)에서 일반적 | 강력한 데이터 바인딩을 지원하는 플랫폼에 적합(e.g. WPF, Xamarin) |
    - MVC와 MVVM 패턴의 실제 차이점 : **결합과 바인딩**
    - 모델과 뷰 사이에 컨트롤러가 없는 경우 데이터 소유권이 더 명확해지고 사용자에게 더 가까이 있게됨
        - 참고로 리액트는 단방향 데이터 흐름을 통해 MVVM을 개선하였고 데이터 소유권이 더욱 제한되어 상태가 필요한 특정 컴포넌트가 상태를 소유함

### KnockOut의 구현 방식

- KnockOut에서 ‘뷰 모델’은 키와 값을 포함하는 자바스크립트 객체로 data-bind 속성을 사용해 페이지의 다양한 요소에 바인딩함
- KnockOut에는 컴포넌트나 템플릿이 없음. 뷰 모델과 뷰 모델을 브라우저 요소에 바인딩하는 방법만 존재
- `createViewModel` 함수를 통해 뷰 모델을 생성하고 `ko.applybindings` 함수를 사용하여 뷰 모델을 브라우저 환경에 연결함
- 문제점
    - 옵저버블을 명시적으로 구독하고 변경에 따라 사용자 인터페이스를 업데이트 하기 위해 많은 작업이 필요(보일러플레이트 코드의 양이 많음)
    - 뷰 모델이 거대해지고 복잡해짐에 따라 리팩터링과 코드 최적화가 불확실해짐

### 1.2.4 앵귤러JS

- 2010년 구글에서 개발됨
- 웹 개발 환경에 지대한 영향을 미친 선구적인 자바스크립트 프레임워크
- 몇 가지 혁신적인 기능을 통합함으로써 리액트를 비롯한 후속 라이브러리에 영향을 미침

### 양방향 데이터 바인딩

- UI와 기반 데이터의 상호 작용을 매우 단순화한 앵귤러JS의 특징적인 기능
- 모델(기반 데이터)이 변경되면 뷰(UI)도 변경사항을 반영하도록 자동으로 업데이트됨(반대의 경우도 마찬가지)

### 모듈식 아키텍처

- 개발자가 애플리케이션의 구성 요소를 논리적으로 분리할 수 있도록 모듈식 아키텍처를 도입
- 각 모듈은 기능을 캡슐화하여 독립적으로 개발, 테스트, 유지 관리가 가능함
- 모듈이라는 개념이 없었던 jQuery나 Backbone과는 크게 다른 부분
- 의존성 모듈을 의존성 주입이라는 패턴을 사용해 주입(이러한 패턴은 앵귤러를 통해 대중화되었음)

### 의존성 주입(Dependency Injection, DI)

- 객체가 의존성을 직접 만드는 대신 의존성을 전달 받는 디자인 패턴
- 자바스크립트 라이브러리에서는 흔하지 않았던 디자인패턴이지만 앵귤러JS가 핵심 기능으로 삼음
- 모듈과 구성 요소를 만들고 관리하는 방식에 큰 영향을 미쳤으며 모듈과 재사용성을 높임
- 예시 - 앵귤러 JS에서 의존성 주입이 작동하는 방식
    
    ```jsx
    var app = angular.module('myApp', []);
    app.controller('myController', function($scope, myService){
    	$scope.greeting = myService.sayHello();
    });
    
    app.factory('myService', function (){
    	return {
    		sayHello: function(){
    			return 'hello, world!';
    		},
    	};
    });
    ```
    
    - 서비스를 의존성으로 선언해 두기만 하면 서비스를 생성하고 주입하는 작업은 앵귤러 JS가 처리
    → 이를 통해 의존성 관리가 간소화되고 컴포넌트의 테스트 가능성과 재사용성이 향상됨

### Backbone과 Knockout 비교

- Backbone VS 앵귤러JS
    - Backbone
        - 개발자에게 코드에 대한 통제력을 조금 더 허용해주었고 제약이 적었음
        → 수정을 해야할 경우 보일러플레이트 코드가 더 많이 필요했음
        - 뷰(DOM)를 직접 변경하는 방법에 대한 규칙 X, 개발자에게 작업을 전가하는 경우가 많았음
    - 앵귤러JS
        - 양반향 데이터 바인딩과 의존성 주입을 통해 더 구조화된 개발이 가능했음. 앵귤러JS의 규칙과 제약은 개발자의 작업 속도를 높임
        - 양방향 데이터 바인딩을 통해 DOM 변형을 처리
- Knockout VS 앵귤러VS
    - Knockout
        - 주로 데이터 바인딩에 중점을 두었으나, 의존성 도구, 모듈식 아키텍처 등은 갖추지 못함
    - 앵귤러JS
        - 기본적으로 의존성 도구, 모듈식 아키텍처 등을 제공하며, SPA 구축을 위한 포괄적인 솔루션을 제공함

### 앵귤러JS 트레이드 오프

- 웹 개발 환경이 거듭 발전하면서 앵귤러JS의 몇몇 특성이 한계나 취약점으로 인식되어 쇠락의 길을 걷게 됨
- 한계, 취약점
    - 성능
        - 변경 사항 감지를 위한 핵심 기능인 앵귤러JS의 다이제스트 주기는 대규모 애플리케이션에서 업데이트 지연과 사용자 인터페이스 응답성 저하의 원인이 될 수 있음
    - 복잡성
        - 앵귤러JS가 도입한 지시자, 컨트롤러, 서비스, 의존성 주입 등 새로운 개념들은 초보자가 배우는데 어려울 정도로 복잡함
    - 앵귤러 2+로의 마이그레이션 문제
        - 앵귤러2 발표 당시 앵귤러JS 1.x와 하위 호환되지 않았고 다트나 타입스크립트로 코드를 작성했어야만 했음. 
        → 이로 인해 앵귤러 커뮤니티가 분열되고 혼란이 생김
    - 복잡한 템플릿 문법
        - 템플릿 속성 내에서 복잡한 자바스크립트 표현식을 허용한 탓에 HTML 안에 프레젠테이션과 비즈니스 로직이 뒤섞이게 됨(템플릿 레이어가 본질적으로 복잡한 로직을 처리하도록 설계되지 않았음)
        → 코드의 유지보수에 문제가 생김
    - 타입 안정성 부재
        - 템플릿은 타입스크립트 같은 정적 유형 검사기에서 작동하지 않았음.
    - 혼동되는 $scope 모델
        - $scope 객체는 뷰와 컨트롤러 사이의 다리 역할을 하지만 동작이 직관적이거나 예측 가능하지 않았음
        → 데이터 바인딩 시 역할과 다른 맥락에서의 동작이 서로 달라 혼동의 원인이 되기도 함
    - 제한적인 개발 도구
        - 디버깅 성능 프로파일링을 위한 다양한 개발 도구를 제공하지 않았음

## 1.3 리액트 등장

- 앵귤러JS의 한계가 부각되면서 리액트가 두각을 드러내기 시작
- 리액트의 핵심 아이디어 → 컴포넌트 기반 아키텍처
- 리액트는 JSX와 컴포넌트 모델. 그리고 단방향 데이터 흐름 패턴을 도입
    
    → 개발자가 애플리케이션을 더 잘 제어하고 데이터의 변화를 더 쉽게 이해할 수 있게 함
    

### 1.3.1 리액트의 핵심 가치

### 선언적 코드와 명령형 코드

- DOM에 대한 선언적 추상화를 제공함
- 리액트는 **우리가 보고자 하는 것**을 코드로 표현하는 방법을 제공하고 실제로 **어떻게 할지는** 리액트가 알아서 처리
- 예시 - 목록 애플리케이션
    
    ```jsx
    function MyList(){
    	const [items, setItems] = useState(['I love']);
    	return (
    		<div>
    			<ul>
    				{items.map((i)=>(
    					<li key={i /* 목록 항목을 고유하게 유지*/}>{i}</li>
    				))}
    			</ul>
    			<NewitemFrom onAddItem={(newItem) => setItems([...items, newItem])} />
    		</div>
    	);
    }
    ```
    
    - MyList 컴포너트를 리액트로 내보내면 리액트가 알아서 안전하고 예측 가능하며 성능이 뛰어난 방식으로 화면에 표현
- 컴포넌트의 역할
    - 사용자 인터페이스에서 이 영역이 어떤 모습이어야 하는지에 대한 설명을 반환하는 것 뿐
    - 이런 설명은 의도한 UI 구조를 가볍게 기술하는 가상 DOM을 사용해서 이루어짐
- 리액트는 업데이트 발생 전과 후의 가상 DOM을 비교하고 실제 DOM의 작은 부분만 성능 좋은 방식으로 업데이트해서 변경된 가상 DOM과 일치시킴

### 가상 DOM

- 실제 DOM을 자바스크립트 객체로 표현하는 프로그래밍 개념(UI 요소의 구조와 속성을 나타내는 자바스크립트 객체)
- 개발자가 실제 DOM을 조작하지 않고도 가상 DOM을 통해 UI를 업데이트 할 수 있음
- 리액트는 가상 DOM을 사용해 컴포넌트의 변경사항을 추적하고 필요할 때만 컴포넌트를 재렌더링함(전체 DOM 트리를 업데이트 하는 방식보다 더 빠르고 효율적)
- 리액트는 실제 DOM 트리와 일치하도록 가상 DOM을 생성하고 업데이트하며 가상 DOM에서 발생한 모든 변경 사항은 재조정이라는 과정을 통해 실제 DOM에 적용됨
- 재조정
    - 새로운 가상 DOM과 이전 가상 DOM을 비교하는 과정
    - 재조정은 이전 가상 DOM트리와 새 가상 DOM 트리를 비교해 실제 DOM의 어느 부분을 업데이트해야하는지 결정하는 과정

### 컴포넌트 모델

- 리액트의 핵심 개념이자 리액트를 강력하게 만드는 동력
    - 똑같은 것은 어디서나 재사용되도록 장려하기 때문에 문제가 발생한 경우 한 곳만 수정해도 관련된 곳이 모두 수정됨
    - 특정 컴포넌트를 반복해서 식별하고 시간의 흐름에 따라 해당 컴포넌트의 업데이트를 줄곧 추적할 수 있다면 리액트는 메모화, 일괄처리, 기타 최적화 작업 등의 성능 관련 작업을 더 쉽게 수행하고 컴포넌트를 더 쉽게 추적할 수 있음
    → 이러한 식별과정을 키잉이라고 함
    - 관심사를 분리하고 로직에 영향을 미치는 사용자 인터페이스에 관련 로직을 더 가깝게 배치할 수 있게 도와줌
    → 여러 컴포넌트를 조합해 사용하는 방식을 합성이라고 함
- 컴포넌트를 통한 개발 방식은 모듈성 향상, 디버깅 용이성, 코드 재사용성, 효율성 향상 등 이점 존재

### 불변 상태

- 리액트 설계 철학 → 애플리케이션 상태를 불변하는 값의 집합으로 기술하는 패러다임 강조
- 각각의 상태 업데이트는 새로운 독립된 스냅샷과 메모리 참조로 취급
- 상태가 변경되면 원래 있던 상태를 직접 변경하는 대신 새 상태를 표현하는 새로운 객체를 반환함 → 변경 사항을 추적하고 디버깅하기 쉬워지며 애플리케이션 동작을 더 잘 이해할 수 있게됨
    - 모든 상태의 전환은 독립적이고 서로 간섭하지 않으므로 가변 상태를 공유하는 것과 달리 탐지하기 어려운 버그 발생 여지가 적음

### 1.3.2 리액트 출시

- 리액트가 오픈 소스로 공개될 당시 엄청난 반발이 일어났음
    - JSX 사용에 대한 것에 비판이 가장 컸음(자바스크립트에 HTML을 넣어서 관심사 분리 원칙을 헤쳤다)
- 페이스북은 리액트 애플리케이션의 데이터 흐름 관리 패턴인 플럭스(Flux)를 발표

### 1.3.3 플럭스 아키텍처

- 클라이언트 측 웹 애플리케이션 구축을 위한 아키텍처 디자인 패턴
- 단방향 데이터 흐름을 강조해 애플리케이션 데이터의 흐름을 더욱 예측 가능하게 만듦
    ![image](https://github.com/user-attachments/assets/fc814752-5213-484e-ba59-4a61c065d668)

    
- 핵심 개념
    - 액션
        - 새 데이터와 액션의 종류를 식별하는 속성을 포함하는 단순한 객체
        - 사용자 상호 작용, 서버 응답, 양식 입력 등 시스템에 대한 내외부 입력을 표현
        - 액션은 중심의 디스패처를 통해 여러 스토어로 보내짐
    - 디스패처
        - 플럭스 아키텍처의 중심
        - 액션을 받아서 애플리케이션에 등록된 스토어로 보냄
        - 모든 스토어는 디스패처에 스토어 자신과 콜백을 등록(이 콜백 목록을 관리하는 것도 디스패처)
        - 액션을 디스패칭하면 등록된 모든 콜백으로 해당 액션을 전송
    - 스토어
        - 애플리케이션 상태와 로직을 포합함
        - MVC 아키첵터 모델과 다소 유사하지만 다수 객체의 상태를 관리하는 것이 차이점
        - 스토어 자신을 디스패처에 등록하고 액션을 처리하는 콜백도 제공
        - 스토어 상태가 업데이트 되면 변경 이벤트를 발생시켜 뷰에 변경된 사항을 알림
    - 뷰
        - 리액트 컴포넌트
        - 스토어에서 변경 이벤트를 받으며 의존하는 데이터가 변경되면 스스로 업데이트함
        - 시스템 상태를 업데이트 하는 새로운 액션을 생성해 단방향 데이터 흐름을 시작하기도 함

### 1.3.4 플럭스 아키텍처의 장점

- 단일 정보 출처
    - 애플리케이션의 상태에 대한 단일 정보 출처가 스토어에 저장됨
        
        → 중앙 집중식 상태관리를 통해 동작을 더 쉽게 예측하고 이해할 수 있음
        
- 테스트 가능성
    - 잘 정의된 구조와 예측 가능한 데이터 흐름을 통해 테스트 가능성이 높아짐
    - 시스템의 여러 부분 간에 관심사를 분리하면 각 부분을 독립적으로 단위 테스트 할 수 있음
- 관심사 분리
    - 시스템 여러 부분의 관심사 분리가 명확함
        
        → 시스템이 더 모듈화 되고 유지보수가 쉬워짐
        

## 1.4 그래서…리액트가 왜 필요한가요?

- 리액트의 핵심 가치인 컴포넌트 기반 아키텍처, 선언적 프로그래밍 모델, 가상 DOM, JSX, 광범위한 생태계 등을 통해 빠르고 확장 가능하며 유지보수가 용이한 웹 애플리케이션을 효율적으로 작성할 수 있음

 

# 2장 - JSX

- JSX
    - 자바스크립트의 확장 구문(eXtension)
    - 자바스크립트 XML

## 2.1 자바스크립트 XML?

- JSX는 개발자가 자바스크립트 코드 내에서 HTML과 유사한 코드를 작성할 수 있게 하는 자바스크릡트용 구문 확장자
- 별도의 언어가 아니라 컴파일러나 트랜스파일러에 의해 자바스크립트 코드로 변환되는 확장 구문(JSX 코드는 컴파일 과정을 거져 일반 자바스크립트 코드로 변환됨)
- JSX 구문과 HTML의 차이
    - JSX는 중괄호를 사용해 HTML과 유사한 코드 내에서 자바스크립트 표현식을 삽입
    - JSX 속성은 카멜 케이스로 작성
        - HTML의 onclick은 JSX에서 onClick

## 2.2 JSX의 장점

- 더 쉬운 읽기 및 쓰기
    - HTML에 익숙한 개발자는 JSX 문법을 더 쉽게 읽고 쓸 수 있음
- 향상된 보안
    - 새로운 엘리먼트를 생성할 수 있는 ‘<’, ‘>’ 과 같은 위험한 문자가 HTML 문자열에 포함되어있다면 JSX 코드를 컴파일할 때 다른 문자로 바꿔 더 안전한 자바스크립트 코드를 생성함(이런 과정을 데이터 소독이라고 표현)
        - ‘<’ → `&lt;`
        - ‘>’ → `&gt;`
- 강력한 타이핑
    - JSX는 타입스크립트로 표현할 수 있지만 타입스크립트가 없어도 JSDoc 스타일 주석이나 propTypes를 활용해 타입 안정성을 향상시킬 수 있음
- 컴포넌트 기반 아키텍처
    - 코드를 보다 모듈화하고 유지보수를 쉽게 하는데 도움이 됨
- 광범위한 사용
    - 리액트 외 라이브러리, 프레임워크에서도 지원됨

## 2.3 JSX의 약점

- 학습 곡선 가중
    - JSX에 익숙하지 않은 개발자는 배우고 이해하기 어려울 수있음
- 전용 도구 필요
    - JSX 코드 실행을 위해 자바스크립트 코드로 컴파일이 필요함(이를 위한 개발 도구가 추가되어야함)
    - Vue.js를 비롯한 일부 프레임워크는 페이지에 <script> 태그만 포함하면 브라우저 환경에서 즉시 작동
- 관심사 혼합
    - 일부 개발자들은 JSX가 HTML과 유사한 코드를 자바스크립트 코드에 결합함으로써 관심사를 혼합시키고 표현과 논리를 분리하기 어렵게 만든다고 주장
- 자바스크립트 호환성 부족
    - 인라인 표현식을 지원하지만 인라인 블록은 지원하지 않음
        
        → JSX 요소의 트리 내부에는 인라인 표현식을 가질 수 있지만 switch, if 블록은 가질 수 없음
        

## 2.4 내부 동작

### 2.4.1 코드는 어떻게 작동하나요?

- 아래 코드는 어떻게 작동할까?
    
    ```jsx
    const a = 1;
    let b = 2;
    console.log(a+b);
    ```
    
- 일단 컴파일러를 사용해 코드를 컴파일!
    - 컴파일러
        - 특정 규칙에 따라 고급 프로그래밍 언어로 작성된 소스코드를 구문 트리로 변환하는 소프트웨어
    - 구문 트리
        - 자바스크립트 객체 같은 트리 자료 구조
        - 코드의 구조를 나타냄
- 코드를 컴파일 하는 과정
    - 어휘 분석, 구문 분석, 의미 분석, 최적화, 코드 생성 등 여러 단계를 통과
- 자바스크립트에서의 컴파일러는 토큰화-구문분석-코드 생성 3단계 과정을 거침
    - 토큰화
        - 문자열을 의미 있는 토큰으로 분해하는 것
        - 토크나이저가 상태를 가지고 있고 각 토큰이 자신의 부모나 자식에 관한 상태를 포함하고 있을 때 토크나이저를 렉서라고 부름
        → 렉싱은 상태를 가지는 토큰화
        - 렉서는 렉서규칙으로 정규 표현식을 사용해 프로그래밍 언어를 나타내는 텍스트 문자열에서 변수 이름, 객체 키 및 값 같은 주요 토큰을 감지 후 구현에 따라 이러한 키워드를 열거 가능한 값으로 표현함
        - 문자열이 토큰화 되거나 렉싱되면 다음 단계인 구문 분석으로 넘어감
    - 구문 분석
        - 토큰화를 가져와 구문 트리로 변환하는 과정
        - 예시 코드를 구문트리로 표현하면 아래와 같음
            
            [AST explorer](https://astexplorer.net/#/gist/0e4ddc084c69c2598a95b1c816e9deb1/ac3fe88595276cfe0771693cd604cc8d3b3a1503)
            
    - 코드 생성
        - 컴파일러가 추상 구문 트리(AST)에서 기계어를 생성하는 과정
        - 컴퓨터 프로세서가 직접 실행할 수 있는 일련의 명령어로 AST의 코드를 변환하는 작업이 포함됨
        - 결과로 생성된 기계어는 자바스크립트 엔진에 의해 실행됨
        - AST를 기계어로 변환하는 과정은 복잡하지만 최신 컴파일러를 통해 최적화된 코드를 생성할 수 있음
- 일반적인 컴파일러의 종류
    - 네티이브 컴파일러
        - 대상 플랫폼의 프로세서에서 직접 실행할 수 있는 기계어를 생성
        - 일반적으로 독립 실행형 애플리케이션이나 시스템 수준의 소프트웨어를 만드는 데 사용됨
    - 크로스 컴파일러
        - 컴파일러가 실행중인 플랫폼과 다른 플랫폼용 기계어를 생성함
        - 임베디드 시스템 개발이나 특수 하드웨어 대상으로 할 때 자주 사용
    - JIT 컴파일러
        - 코드를 미리 변환하지 않고 실행할 때 기계어로 변환
        - 자바 가상 머신 같은 가상 머신에서 일반적으로 사용됨
        - 기존 인터프리터보다 성능이 훨씬 우수
    - 인터프리터
        - 컴파일하지 않고 소스코드를 직접 실행
        - 일반적으로 컴파일러보다 속도가 느리지만 유연성과 사용 편의성이 우수함
- 웹 브라우저를 비롯한 최신 환경에서는 자바스크립트 코드를 효율적으로 실행하기 위해 **JIT 컴파일러를 많이 사용**함
- 런타임
    - 보통 엔진과 연동해 특정 환경에 맞는 컨텍스트 헬퍼와 기능을 더 많이 제공
    - 가장 인기있는 자바스크립트 런타임은 구글 크롬과 같은 일반적인 웹 브라우저
        - 크롬 웹 브라우저는 엔진과 연동하는 크로미움 런타임을 제공
        - 서버측에서는 V8엔진을 사용하는 Node.js 런타임을 사용함
    - 런타임은 자바스크립트 엔진에 브라우저 런타임이 제공하는 window 객체와 document 객체 같은 컨텍스트를 제공함

### 2.4.2 JSX로 자바스크립트 구문 확장하기

- JSX로 자바스크립트 구문을 확장하려면 새로운 구문을 이해하는 다른 엔진이 필요하거나 엔진보다 앞서 새로운 구문을 처리해야함
    - JSX만을 위한 새로운 엔진을 만드는 것은 거의 불가능하므로 후자의 방법이 더 쉬움
    - 새 구문이 엔진에 도달하기 전에 처리하기 위해 확장 언어로 작성된 코드 문자열을 이해할 수 있는 렉서와 구문 분석기를 만들어야함
        - 구문 트리를 사용해 **기존의 모든 자바스크립트 엔진이 이해할 수 있는 일반적인 바닐라 JS를 생성**
            
            **→ 자바스크립트 생태계에서 `바벨`이 하는 일(타입스크립트, 트레이서, SWC 같은 도구가 하는 일)**
            
        - 새로운 JSX 엔진 제작 VS JS 전처리기 사용
            ![image](https://github.com/user-attachments/assets/556f71e5-9ef5-4418-9e34-bac2d9527120)

            
        - 위와 같은 이유로 JSX는 브라우저에서 직접 사용할 수 없고 특수한 구문 분석기를 통해 구문 트리로 컴파일하는 ‘빌드 단계’가 필요.
        - 코드는 이러한 과정을 거쳐 바닐라 JS로 변환되어 최종 배포용 번들에 포함됨
            
            → 이 과정을 **트랜스파일**한다고 표현
            
        - 트랜스파일 : 한 언어로 작성된 소스 코드를 추상화 수준이 비슷한 다른 언어로 변환하는 과정. 소스 대 소스 컴파일이라고도 함

## 2.5 JSX 프라그마

- 프라그마는 일반적으로 언어 자체에 내포된 것 이상의 추가 정보를 컴파일러에 제공할 때 사용하는 컴파일러 지시어를 뜻함(자바스크립트의 경우 `'use strict'` mode 등)
- JSX 프라그마는 모두 `<` 로 시작
    - `<` 문자는 자바스크립트에서 인식할 수 없음**(비교 연산 제외)**
    → 엔진이 해당 문자를 발견하면 문법 오류를 던짐
        
        > Syntax Error: Unexpected token ‘<’
        > 
- JSX에서는 JSX 프라그마가 함수 호출로 변환될 수 있음
- 구문 분석기가 `<` 프라그마를 만날 때 호출할 함수의 이름은 설정 가능하지만 `React.createElement(예전 버전)`  또는 `_jsxs(최신 버전)` 가 기본 값으로 정해짐
- pragma 함수 시그니처
    
    ```jsx
    function pragma(tag, props, ...children)
    ```
    
- JSX가 일반 자바스크립트 구문으로 바뀌는 형식
    - JSX 코드
        
        ```jsx
        <MyComponent prop='속성값'>콘텐츠</MyComponent>
        ```
        
    - 자바스크립트 코드로 변환 후
        
        ```jsx
        React.createElement(MyComponent , {prop: '속성값'}, '콘텐츠');
        ```
        
    - 코드를 보면 알 수 있듯이 사실상 JSX 프라그마는 React.createElement 대신 `<` 문자를 사용하는 별칭에 불과함

## 2.6 표현식

- JSX는 엘리먼트 트리 내부에서 코드 실행이 가능
- 아래 예시처럼 중괄호 안에 실행 코드를 넣으면 됨
    
    ```jsx
    const a = 1;
    const b = 2;
    const MyComponent  = () => <Box>표현식입니다: {a + b}</Box>;
    ```
    
- JSX 표현식을 사용하면 목록 반복, 삼항 연상자를 사용한 조건 검사, 문자열 치환 등 다양한 표현식 실행이 가능
- JSX 표현식은 JSX 엘리먼트 트리 내부에서는 문장 실행이 불가능함(표현식이기 때문에!)
    
    ```jsx
    const MyComponent = () => <Box>표현식입니다: {
    	const a = 1;
    	const b = 2;
    	if(a > b){
    		3
    	}
    }</Box>;
    ```
    
    - 문장이 아무 값도 반환하지 않고, 상태를 설정하는 부작용으로 간주되어 동작하지 않음
    - 렌더러는 if문 내의 3는 숫자를 보고 3을 출력하라는 건지 아닌지 알 수 없음
