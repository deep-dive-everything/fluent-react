# 1장 입문자를 위한 지식

2025.02.16 dasom



## 1.1 리액트는 왜 필요한가요?

> 리액트가 필요한 이유는 **업데이트** 때문이다.

웹이 발전함에 따라 웹에서 우수한 사용자 경험을 제공하고자 하는 필요가 발생했다. 그러나 다음과 같은 이유로 인해 즉각적인 업데이트를 대규모로 실현하는 데에 제약이 있었다.

**성능**

​	웹 페이지를 업데이트하면 브라우저가 페이지의 레이아웃을 다시 계산(리플로)하고 그리는 작업을 수행해 성능 병목 현상 발생

**신뢰성**

​	웹 전반에서 상태를 추적해 일관되게 유지하기 어려움

**보안**

​	크로스 사이트 스크립팅(XSS) 및 크로스 사이트 요청 위조(CSRF) 같은 악용 방지를 위해 페이지에 삽입하는 모든 HTML과 자바스크립트의 소독 필요

> memo!
>
> XSS: 사용자 입력을 제대로 검증하지 않아, 악성 스크립트(보통 JavaScript)가 삽입되고 실행되는 취약점
>
> CSRF: 용자가 신뢰하는 웹사이트에서 **인증된 상태**를 악용하여 공격자가 원치 않는 요청을 강제로 수행하게 하는 공격



## 1.2 리액트 이전의 세계

예시 상황: 사용자가 버튼을 클릭 - 어떤 동작 수행 - 상태를 반영해 인터페이스 업데이트

예시 상황에서의 인터페이스 상태

**클릭 전**

**클릭했지만 대기 중**

**클릭 후 성공**

**클릭 후 실패**



사용자 인터페이스 업데이트 단계

1. 호스트 환경(브라우저)에서 document.querySelector 또는 document.getElementById 같은 엘리멘트 탐색 API를 사용해 버튼을 찾음
2. 버튼에 이벤트 리스너를 추가해 클릭 이벤트 추적
3. 이벤트에 반응해 상태 업데이트
4. 페이지에서 벗어날 때는 버튼의 이벤트 리스너를 제거하고 모든 상태 정리



이에 더해 데이터 저장, 상태 저장 방식 등 다양한 요인들을 고려해야 함



다른 예시 상황: 항목 목록 추가

위 상황에서 문제 발생의 원인

1. 오류가 쉽게 생김

   on submit 속성은 다른 클라이언트 측 자바스크립트에서 손쉽게 접근해 변경 가능 (addEventListner를 대신 사용해도 다른 문제가 발생함)

2. 예측 불가

   DOM의 기존 엘리멘트에 의존하여 HTML과 자바스크립트가 상호 의존함. 따라서 id가 동일하거나, 아니면 엘리멘트가 없거나, tag가 잘못 작성했거나, id가 아닌 클래스가 사용됐거나 하는 상황에 따라 문제가 발생할 수 있음

3. 비효율적

   목록을 렌더링하는 함수는 항목을 순차적으로 화면에 렌더링함. DOM의 변형 계산 비용은 레이아웃 이동이나 리플로가 발생할 때 더 비쌈



위와 같은 문제를 해결하기 위해 자바스크립트 기반 솔루션이 등장하기 시작함

### jQuery

jQuery는 능동적으로 DOM을 조작함

하지만 코드의 어느 곳에서든 페이지 구조를 전역적으로 수정할 수 있었고,  불러들인 코드에서도 마찬가지였기에 상호작용이 복잡하고 동작 파악하기가 난해했음

또한 테스트 환경은 실제 브라우저가 아니라 코드를 테스트하려면 브라우저를 흉내내야했음

jQuery가 인기를 잃은 이유

* 크기 및 로딩 시간

* 최신 브라우저와의 중복성

  브라우저 발전에 따라 jQuery를 사용해야만 했던 기능(일관된 DOM조작이나 데이터 로딩 관련 네트워크 등)을 브라우저에서 지원함

* 성능 고려 사항



따라서 jQuery를 사용하되 예측 가능성과 재사용성을 보강한 Backbone 등이 등장하기 시작함

### Backbone

MVC 패턴을 자체적으로 해석했으며 브라우저와 자바스크립트간 상태 불일치, 코드 재사용, 테스트 가능성 등을 처음으로 해결함

> MVC 패턴
>
> **모델**
>
> 애플리케이션의 데이터와 비즈니스 규칙을 담당 (로직이 사용자 인터페이스에서 분리)
>
> **뷰**
>
> 사용자 인터페이스를 나타냄
>
> **컨트롤러**
>
> 모델과 뷰 사이의 인터페이스 역할을 수행함



> 웹 애플리케이션이 발전하며 MVC 패턴 역시 한계에 다다름
>
> **복잡한 상호 작용 및 상태 관리**
>
> 대화형 요소가 많은 복잡한 사용자 인터페이스를 관리할 때 어려움을 겪음. 앱 규모가 커지며 늘어난 컨트롤러 때문에 상태변경과 UI의 다양한 부분에 미치는 영향을 관리하기 어려워짐
>
> **양방향 데이터 바인딩**
>
> 뷰가 모델과 동기화되지 않거나 반대로 모델이 뷰와 동기화되지 않는 등의 문제 발생
>
> **강한 결합**
>
> 일부 MVC  구현에서는 모델, 뷰, 컨트롤러가 강하게 결합되어 다른 구성 요소에 영향을 주지 않고 독립적으로 하나만 변경하거나 리팩터링 하기 어려울 수 있음



Backbone과 관련된 단점

* 장황한 코드 및 보일러플레이트
* 양방향 데이터 바인딩 부족
* 이벤트 중심 아키텍처
* 조합성 부족



### Knockout

'옵저버블'과 '바인딩'을 활용해 의존성을 추적하는 라이브러리로 최초의 반응형 자바스크립트 라이브러리

cf. 옵저버블: 데이터의 출처 / 바인딩: 데이터를 소비하고 렌더링하는 사용자 인터페이스

MVVM 디자인 패턴을 사용함

> MVVM 패턴
>
> **모델**
>
> 애플리케이션의 데이터와 비즈니스 규칙을 담당
>
> **뷰**
>
> 사용자 인터페이스를 나타냄
>
> **뷰 모델**
>
> 모델과 뷰 사이의 다리 역할을 함



> MVVM 패턴의 장점
>
> **테스트 가능성**
>
> 뷰에서 뷰모델을 분리하면 UI 포함 없이 프레젠테이션 로직에 대한 단위 테스트 가능
>
> **재사용성**
>
> 뷰 모델은 여러 뷰 혹은 플랫폼에서 재사용 가능
>
> **유지 보수성**
>
> 명확한 분리를 통해 코드를 관리, 확장, 리팩터링하기 더 쉬워짐
>
> **데이터 바인딩**
>
> UI 업데이트에 필요한 보일러 플레이트 코드의 양을 줄여줌



cf. MVC 패턴과 MVVM 패턴에 대해: https://velog.io/@somda/MVC-MVVM-%EA%B7%B8%EB%A6%AC%EA%B3%A0-Flux



Knockout은 createViewModel 함수를 사용해 생성한 뷰 모델에 HTML 요소를 바인딩해 사이트와 사용자 간의 상호작용을 가능하게 함

하지만 많은 보일러플레이트 코드가 필요했고, 뷰 모델이 거대해짐에 따라 리팩터링과 코드 최적화가 불확실해짐



### 앵귤러 JS

2010년 구글에서 개발

앵귤러JS의 특징

* 양방향 데이터 바인딩

  모델이 변경되면 뷰도 변경 사항을 반영하도록 자동으로 업데이트

  ```html
  <!DOCTYPE html>
    <html>
    <head>
    	<script 		src="https://ajax.googleapis.com/ajax/libs/angularjs/1.8.2/angular.min.js">
       </script>
  		</head>
  	<body ng-app="">
    	<p>Name: <input type="text" ng-model="name" /></p> 
    	<p ng-if="name">안녕하세요, {{name}} 님!</p> 
  	</body>
  </html>
  ```

* 모듈식 아키텍처

​	구성 요소를 논리적으로 분리. 모듈은 기능을 캡슐화하며 독립적으로 개발, 테스트, 유지 관리가 가능함

​	이런 의존성을 루트 app에 의존성 주입이라는 패턴을 사용해 주입함

* 의존성 주입 (dependency injection, DI)

  객체가 의존성을 직접 만드는 대신 전달받는 디자인 패턴 



**Backbone과 Knockout 비교**

Backbone과 Knockout은 앵귤러JS가 등장할 당시 사용되던 라이브러리.

Backbone

* 개발자에게 코드에 대한 통제력을 조금 더 허용 / 앵귤러JS보다 제약이 적었음 -> 오히려 보일러플레이트가 더 많이 필요함
* 뷰를 직접 변경하는 방법에 대한 규칙이 없었음

Knockout

* 데이터 바인딩에 중점을 두었지만 앵귤러가 제공하는 기능은 갖추지 못했음



**앵귤러JS가 쇠락하게 된 이유**

* 성능
* 복잡성: 초보자가 배우기 어려웠음
* 앵귤러 2+로의 마이그레이션 문제: 앵귤러JS 1.x와 하위 호환되지 않았음
* 복잡한 템플릿 문법
* 타입 안정성 부재
* 혼동되는 $scope 모델: 뷰와 컨트롤러 사이의 다리 역할을 하지만 직관적이거나 예측 가능하지 않았음. 데이터 바인딩할 때의 역할과 다른 맥락에서의 동작이 다른 경우 발생.
* 제한적인 개발 도구: 디버깅 성능 프로파일링을 위한 다양한 개발 도구를 제공하지 않았음



## 1.3 리액트 등장

리액트가 제시한 핵심 아이디어: 컴포넌트 기반 아키텍처



### 리액트의 핵심 가치

* 선언적 코드와 명령형 코드

  DOM에 대한 선언적 추상화를 제공함. (무엇을 완료하고 싶은지 작성하면 어떻게 할지는 리액트가 알아서 함)

* 가상 DOM

  실제 DOM을 자바스크립트 객체로 표현하는 프로그래밍 개념으로 실제 DOM을 조작하지 않고도 UI를 업데이트 할 수 있게 됨 (재조정 과정을 통해 실제 DOM에 적용)

* 컴포넌트 모델

​	애플리케이션을 작은 조각으로 나누기를 권장 -> 재사용이 가능하며 유지보수가 용이함

* 불변 상태

  애플리케이션 상태를 불변하는 값의 집합으로 기술 -> UI가 특정 시점의 특정 상태를 반영하도록 보장함. 상태의 불변성 덕분에 Replay.io 처럼 시간 여행 디버깅을 지원하는 강력한 개발자 도구도 사용할 수 있음



### 리액트 출시

2013년 오픈소스로 공개 당시에는 JSX가 자바스크립트에 HTML을 넣어 관심사 분리 원칙을 해쳤다고 비난 받음. 그러나 점진적으로 웹에서 사용자 인터페이스를 구축하는 사실상 표준으로 자리 잡음.



### 플럭스 아키텍처

플럭스: 클라이언트 측 웹 어플리케이션 구축을 위한 아키텍처 디자인 패턴으로, 단방향 데이터 흐름을 강조하여 애플리케이션 데이터 흐름을 예측 가능하게 만듦.

> **액션**
>
> 새 데이터와 액션의 종류를 식별하는 속성을 포함하는 단순 객체
>
> **디스페처**
>
> 플럭스 아키텍서의 중심으로, 액션을 받아 등록된 스토어로 보냄
>
> **스토어**
>
> 애플리케이션의 상태와 로직을 포함함. 모델과 유사하지만 스토어는 다수 객체의 상태를 관리함
>
> **뷰**
>
> 리액트 컴포넌트로, 스토어에서 변경 이벤트를 받아 의존하는 데이터가 변경되면 스스로 업데이트함



### 플럭스 아키텍처의 장점

* 단일 정보 출처: 중앙 집중식 상태 관리
* 테스트 가능성
* 관심사 분리



## 1.4 그래서_ 리액트는 왜 필요한가요?

* 우리가 화면에 나타내고자 하는 바를 선언적으로 표현 가능해짐
* 대규모로 사용가능하도록 설계됨 (심지어 메타가)
* 오픈소스이며 무료로 사용 가능
* 활발한 생태계 
* 플랫폼에 구애받지 않음




---


# 2장 JSX

2025.02.16 dasom



> JSX의 X는 자바스크립트의 확장 구문(eXtension)을 뜻한다. 자바스크립트 XML이라고도 한다.

## 2.1 자바스크립트 XML?

JSX는 별도의 언어가 아닌, 컴파일러나 트랜스파일러에 의해 **자바스크립트 코드로 변환**되는 확장 구문이다

JSX와 HTML의 차이

* JSX는 중괄호{}를 이용해 HTML과 유사한 코드 내에 자바스크립트 표현식을 삽입한다
* JSX속성은 HTML속성과 달리 카멜 케이스로 작성된다 (e.g. HTML의 onclick은 onClick)

```jsx
const MyComponent = () => ( 
  <section id="list"> 
  	<h1>내가 만든 목록!</h1> 
  	<p>대단하지 않나요? 멋진 것들이 모여 있습니다!</p> 
  	<ul> {amazingThings.map((t) => ( 
  		<li key={t.id}>{t.label} </li> 
		))} 
    </ul> 
  </section> 
); 
```

```js
// 초기 버전의 JSX 변환기
const MyComponent = () => 
	React.createElement( 
    "section", 
    { id: "list" }, 
    React.createElement("h1", {}, "내가 만든 목록!"), 
    React.createElement( "p", {}, "대단하지 않나요? 멋진 것들이 모여 있습니다!" ),
    React.createElement( "ul", {}, amazingThings.map((t) => 
    	React.createElement("li", { key: t.id }, t.label) 
      ) 
    ) 
  );
```



## 2.2 JSX의 장점

* 더 쉬운 읽기 및 쓰기
* 향상된 보안: 새로운 엘리먼트를 생성할 수 있는 '<'나 '>' 같은 문자가 HTML 문자열에 포함되었다면 JSX 코드를 컴파일 할 때 다른 문자로 바꿔 더 안전한 자바스크립트 코드를 생성함. 
* 강력한 타이핑: 타입스크립트가 없어도 JSDoc 스타일의 주석을 사용하거나 propTypes를 사용해 타입 안정성 향상 가능
* 컴포넌트 기반 아키텍처
* 광범위한 사용: 리액트가 아닌 라이브러리와 프레임워크에서도 사용



## 2.3 JSX의 약점

* 학습 곡선 가중
* 전용 도구 필요: 자바스크립트 코드로 컴파일해야 해 이를 위한 개발 도구가 추가되어야 함
* 관심사 복합: 일부 개발자들은 HTML과 유사한 코드가 자바스크립트 코드에 결합해 관심사가 혼합되어 표현과 논리를 분리하기 어렵게 만든다고 주장
* 자바스크립트 호환성 부족: JSX는 인라인 표현식을 지원하지만 인라인 블록은 지원하지 않음 (따라서 switch와 if 블록은 사용 불가)



## 2.4 내부 동작

```jsx
const a = 1;
let b = 2;
console.log(a + b);
```



### 코드는 어떻게 작동하나요?

컴퓨터가 코드를 해석하고 실행하기 위해서는 **컴파일러를 통해 고급 프로그래밍 언어로 작성된 소스 코드를 구문 트리로 변환**해주어야 한다

컴파일러의 변환 과정

* 토큰화

​	문자열을 의미 있는 토큰으로 분해함. 

​	토크나이저가 상태를 가지며, 각 토큰이 부모나 자식에 대한 상태를 포함할 때는 토크나이저를 렉서라고 부름. 즉, 렉싱은 상태를 가지는 토큰화이다

​	렉서는 렉서 규칙에 따라 정규 표현식을 사용해 문자열에서 변수 이름, 객체 키 값 같은 주요 토큰을 감지함.

​	이후 렉서는 구현에 따라 이러한 키워드를 열거 가능한 값으로 표현함 (e.g. const는 0, let은 1로)

* 구문 분석

  토큰을 가져와 구문 트리로 변환하는 과정, 구문 분석기로 문자열은 JSON 객체가 됨

* 코드 생성

  추상 구문 트리 (AST)에서 기계어를 생성하는 과정

  이후 결과로 생성된 기계어는 자바스크립트 엔진에 의해 실행됨



컴파일러의 종류

* 네이티브 컴파일러: 대상 플랫폼의 프로세서에서 직접 실행할 수 있는 기계어 생성

* 크로스 컴파일러: 컴파일러가 실행 중인 플랫폼과 다른 플랫폼용 기계어를 생성

* JIT 컴파일러: 코드를 미리 변환하지 않고 실행할 때 기계어로 변환

  웹 브라우저를 비롯해 최신 환경에서는 JIT 컴파일러를 주로 사용

  자바스크립트 소스 코드가 먼저 바이트코드 같은 중간 표현으로 변환되고, JIT 컴파일러는 프로그램이 실행될 때 이 바이트 코드를 기계어로 동적 컴파일 함

* 인터프리터: 컴파일하지 않고 소스 코드를 직접 실행



런타임은 일반적으로 엔진과 연동해 특정 환경에 맞는 콘텍스트 헬퍼와 같은 기능을 제공

자바스크립트 런타임: 크롬 같은 일반적 웹 브라우저 또는 Node.js (모두 window 객체나 document 같은 콘텍스트를 제공)



### JSX로 자바스크립트 구문  확장하기

자바스크립트 구문을 확장하기 위해서는 새로운 구문을 이해하는 다른 엔진이 있거나, 엔진보다 앞서 새로운 구문을 처리해야 함

맞춤형 특수 엔진을 만드는 것보다 후자가 더 쉽기 때문에, **확장 언어로 작성된 코드 문자열을 이해할 수 있는 렉서와 구문 분석기**를 만듦 -> 자바스크립트 **바벨**의 역할 (타입스크립트, 트레이서, SWC 같은 도구가 하는 일이기도 함)

> cf. SWC (Speedy Web Compiler)란?
>
> 자바스크립트 프로젝트의 컴파일과 번들링에 사용하며 Rust 언어로 제작된 빌드 툴 - 출처: https://fe-developers.kakaoent.com/2022/220217-learn-babel-terser-swc/)

따라서 JSX는 브라우저에서 직접 사용할 수 없고, '빌드 단계'가 필요함. 빌드 과정을 거쳐 바닐라JS로 변환되어 최종 배포용 번들에 포함되는데 이 과정을 **트랜스파일한다**라고 함 (소스대 소스 컴파일이라고도 함)



## 2.5 JSX 프라그마

> JSX 프라그마?
>
> 책 설명: 컴파일러에 특정 작업을 수행하도록 지시하는 지시어 
>
> GPT: JSX 변환을 커스터마이징하는 기능



JSX 프라그마는 모두 <로 시작하는데, 자바스크립트 엔진은 이 문자를 발견하면 `SyntaxError: Unexpected token '<'` 오류를 발생시킴. JSX에서는 이런 JSX 프라그마가 함수 호출로 변환될 수 있음

프라그마를 통해 파일의 일부 콘텐츠를 처리하는 방법 등을 컴파일러에 지시할 수 있음 (e.g. use strict)

`function pragma(tag, props, ...children)`

JSX가 일반 자바스크립트 구문으로 바뀌는 방식

`<MyComponent prop="속성값">콘텐츠</MyComponent>`

-> `React.createElement(MyComponent, {props: "속성값"}, "콘텐츠")`



> **프라그마 더 보기**
>
> 위의 예시에서
>
> JSX는 결국 **`React.createElement` 함수 호출로 변환됨**
> 즉, 기본적으로 **React를 import해야 JSX를 사용할 수 있음** (React 버전 17 미만인 경우)
>
> JSX 프라그마는 JSX를 변환할 때 `React.createElement` 대신 **다른 함수**를 사용하도록 지정하는 역할도 수행함
> 이걸 사용하면 **React 없이 JSX를 사용할 수도 있다.**
>
> JSX 프라그마는 **파일 상단의 주석**으로 지정할 수도 있고, **Babel 설정에서 전역적으로 변경할 수도 는데**
>
> // 파일상단 주석
>
> /** @jsx customCreateElement */
>
> // 바벨 전역 설정
>
> {
>   "presets": ["@babel/preset-react"],
>   "plugins": [
>     ["@babel/plugin-transform-react-jsx", { "pragma": "customCreateElement" }]
>   ]
> }
>
> 이렇게 하면 위의 예시는
>
> customCreateElement(MyComponent, {props: "속성값"}, "콘텐츠")로 바뀜



## 2.6 표현식

JSX의 강력한 기능 중 하나는 엘리먼트 트리 내부에서 코드를 실행하는 것

단, JSX 표현식은 말 그대로 표현식이기 때문에 if문 switch문과 같은 문장은 동작하지 않음

```jsx
const a = 1;
const b = 2;
// 가능
const MyComponent = () => <Box>b가 a보다 큽니까? {b > a ? "네" : "아니오"}</Box>

// 불가능
const MyCompo = () => <Box>a + b? {
    const a = 1;
    const b = 2;
    if (a > b) {
      3
    }
  }</Box>
```


