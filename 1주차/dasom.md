# 1장 입문자를 위한 지식

2025.02.16 dasom



## 1.1 리액트는 왜 필요한가요?

> 리액트가 필요한 이유는 **업데이트** 때문이다.

웹이 발전함에 따라 웹에서 우수한 사용자 경험을 제공하고자 하는 필요가 발생했다. 그러나 다음과 같은 이유로 인해 즉각적인 업데이트를 대규모로 실현하는 데에 제약이 있었다.

**성능**

​	웹 페이지를 업데이트하면 브라우저가 페이지의 레이아웃을 다시 계산(리플로)하고 그리는 작업을 수행해 성능 병목 현상 발생

**신뢰성**

​	웹 전반에서 상태를 추적해 일관되게 유지하기 어려움

**보안**

​	크로스 사이트 스크립팅(XSS) 및 크로스 사이트 요청 위조(CSRF) 같은 악용 방지를 위해 페이지에 삽입하는 모든 HTML과 자바스크립트의 소독 필요

> memo!
>
> XSS: 사용자 입력을 제대로 검증하지 않아, 악성 스크립트(보통 JavaScript)가 삽입되고 실행되는 취약점
>
> CSRF: 용자가 신뢰하는 웹사이트에서 **인증된 상태**를 악용하여 공격자가 원치 않는 요청을 강제로 수행하게 하는 공격



## 1.2 리액트 이전의 세계

예시 상황: 사용자가 버튼을 클릭 - 어떤 동작 수행 - 상태를 반영해 인터페이스 업데이트

예시 상황에서의 인터페이스 상태

**클릭 전**

**클릭했지만 대기 중**

**클릭 후 성공**

**클릭 후 실패**



사용자 인터페이스 업데이트 단계

1. 호스트 환경(브라우저)에서 document.querySelector 또는 document.getElementById 같은 엘리멘트 탐색 API를 사용해 버튼을 찾음
2. 버튼에 이벤트 리스너를 추가해 클릭 이벤트 추적
3. 이벤트에 반응해 상태 업데이트
4. 페이지에서 벗어날 때는 버튼의 이벤트 리스너를 제거하고 모든 상태 정리



이에 더해 데이터 저장, 상태 저장 방식 등 다양한 요인들을 고려해야 함



다른 예시 상황: 항목 목록 추가

위 상황에서 문제 발생의 원인

1. 오류가 쉽게 생김

   on submit 속성은 다른 클라이언트 측 자바스크립트에서 손쉽게 접근해 변경 가능 (addEventListner를 대신 사용해도 다른 문제가 발생함)

2. 예측 불가

   DOM의 기존 엘리멘트에 의존하여 HTML과 자바스크립트가 상호 의존함. 따라서 id가 동일하거나, 아니면 엘리멘트가 없거나, tag가 잘못 작성했거나, id가 아닌 클래스가 사용됐거나 하는 상황에 따라 문제가 발생할 수 있음

3. 비효율적

   목록을 렌더링하는 함수는 항목을 순차적으로 화면에 렌더링함. DOM의 변형 계산 비용은 레이아웃 이동이나 리플로가 발생할 때 더 비쌈



위와 같은 문제를 해결하기 위해 자바스크립트 기반 솔루션이 등장하기 시작함

### jQuery

jQuery는 능동적으로 DOM을 조작함

하지만 코드의 어느 곳에서든 페이지 구조를 전역적으로 수정할 수 있었고,  불러들인 코드에서도 마찬가지였기에 상호작용이 복잡하고 동작 파악하기가 난해했음

또한 테스트 환경은 실제 브라우저가 아니라 코드를 테스트하려면 브라우저를 흉내내야했음

jQuery가 인기를 잃은 이유

* 크기 및 로딩 시간

* 최신 브라우저와의 중복성

  브라우저 발전에 따라 jQuery를 사용해야만 했던 기능(일관된 DOM조작이나 데이터 로딩 관련 네트워크 등)을 브라우저에서 지원함

* 성능 고려 사항



따라서 jQuery를 사용하되 예측 가능성과 재사용성을 보강한 Backbone 등이 등장하기 시작함

### Backbone

MVC 패턴을 자체적으로 해석했으며 브라우저와 자바스크립트간 상태 불일치, 코드 재사용, 테스트 가능성 등을 처음으로 해결함

> MVC 패턴
>
> **모델**
>
> 애플리케이션의 데이터와 비즈니스 규칙을 담당 (로직이 사용자 인터페이스에서 분리)
>
> **뷰**
>
> 사용자 인터페이스를 나타냄
>
> **컨트롤러**
>
> 모델과 뷰 사이의 인터페이스 역할을 수행함



> 웹 애플리케이션이 발전하며 MVC 패턴 역시 한계에 다다름
>
> **복잡한 상호 작용 및 상태 관리**
>
> 대화형 요소가 많은 복잡한 사용자 인터페이스를 관리할 때 어려움을 겪음. 앱 규모가 커지며 늘어난 컨트롤러 때문에 상태변경과 UI의 다양한 부분에 미치는 영향을 관리하기 어려워짐
>
> **양방향 데이터 바인딩**
>
> 뷰가 모델과 동기화되지 않거나 반대로 모델이 뷰와 동기화되지 않는 등의 문제 발생
>
> **강한 결합**
>
> 일부 MVC  구현에서는 모델, 뷰, 컨트롤러가 강하게 결합되어 다른 구성 요소에 영향을 주지 않고 독립적으로 하나만 변경하거나 리팩터링 하기 어려울 수 있음



Backbone과 관련된 단점

* 장황한 코드 및 보일러플레이트
* 양방향 데이터 바인딩 부족
* 이벤트 중심 아키텍처
* 조합성 부족



### Knockout

'옵저버블'과 '바인딩'을 활용해 의존성을 추적하는 라이브러리로 최초의 반응형 자바스크립트 라이브러리

cf. 옵저버블: 데이터의 출처 / 바인딩: 데이터를 소비하고 렌더링하는 사용자 인터페이스

MVVM 디자인 패턴을 사용함

> MVVM 패턴
>
> **모델**
>
> 애플리케이션의 데이터와 비즈니스 규칙을 담당
>
> **뷰**
>
> 사용자 인터페이스를 나타냄
>
> **뷰 모델**
>
> 모델과 뷰 사이의 다리 역할을 함



> MVVM 패턴의 장점
>
> **테스트 가능성**
>
> 뷰에서 뷰모델을 분리하면 UI 포함 없이 프레젠테이션 로직에 대한 단위 테스트 가능
>
> **재사용성**
>
> 뷰 모델은 여러 뷰 혹은 플랫폼에서 재사용 가능
>
> **유지 보수성**
>
> 명확한 분리를 통해 코드를 관리, 확장, 리팩터링하기 더 쉬워짐
>
> **데이터 바인딩**
>
> UI 업데이트에 필요한 보일러 플레이트 코드의 양을 줄여줌



cf. MVC 패턴과 MVVM 패턴에 대해: https://velog.io/@somda/MVC-MVVM-%EA%B7%B8%EB%A6%AC%EA%B3%A0-Flux



Knockout은 createViewModel 함수를 사용해 생성한 뷰 모델에 HTML 요소를 바인딩해 사이트와 사용자 간의 상호작용을 가능하게 함

하지만 많은 보일러플레이트 코드가 필요했고, 뷰 모델이 거대해짐에 따라 리팩터링과 코드 최적화가 불확실해짐



### 앵귤러 JS

2010년 구글에서 개발

앵귤러JS의 특징

* 양방향 데이터 바인딩

  모델이 변경되면 뷰도 변경 사항을 반영하도록 자동으로 업데이트

  ```html
  <!DOCTYPE html>
    <html>
    <head>
    	<script 		src="https://ajax.googleapis.com/ajax/libs/angularjs/1.8.2/angular.min.js">
       </script>
  		</head>
  	<body ng-app="">
    	<p>Name: <input type="text" ng-model="name" /></p> 
    	<p ng-if="name">안녕하세요, {{name}} 님!</p> 
  	</body>
  </html>
  ```

* 모듈식 아키텍처

​	구성 요소를 논리적으로 분리. 모듈은 기능을 캡슐화하며 독립적으로 개발, 테스트, 유지 관리가 가능함

​	이런 의존성을 루트 app에 의존성 주입이라는 패턴을 사용해 주입함

* 의존성 주입 (dependency injection, DI)

  객체가 의존성을 직접 만드는 대신 전달받는 디자인 패턴 



**Backbone과 Knockout 비교**

Backbone과 Knockout은 앵귤러JS가 등장할 당시 사용되던 라이브러리.

Backbone

* 개발자에게 코드에 대한 통제력을 조금 더 허용 / 앵귤러JS보다 제약이 적었음 -> 오히려 보일러플레이트가 더 많이 필요함
* 뷰를 직접 변경하는 방법에 대한 규칙이 없었음

Knockout

* 데이터 바인딩에 중점을 두었지만 앵귤러가 제공하는 기능은 갖추지 못했음



**앵귤러JS가 쇠락하게 된 이유**

* 성능
* 복잡성: 초보자가 배우기 어려웠음
* 앵귤러 2+로의 마이그레이션 문제: 앵귤러JS 1.x와 하위 호환되지 않았음
* 복잡한 템플릿 문법
* 타입 안정성 부재
* 혼동되는 $scope 모델: 뷰와 컨트롤러 사이의 다리 역할을 하지만 직관적이거나 예측 가능하지 않았음. 데이터 바인딩할 때의 역할과 다른 맥락에서의 동작이 다른 경우 발생.
* 제한적인 개발 도구: 디버깅 성능 프로파일링을 위한 다양한 개발 도구를 제공하지 않았음



## 1.3 리액트 등장

리액트가 제시한 핵심 아이디어: 컴포넌트 기반 아키텍처



### 리액트의 핵심 가치

* 선언적 코드와 명령형 코드

  DOM에 대한 선언적 추상화를 제공함. (무엇을 완료하고 싶은지 작성하면 어떻게 할지는 리액트가 알아서 함)

* 가상 DOM

  실제 DOM을 자바스크립트 객체로 표현하는 프로그래밍 개념으로 실제 DOM을 조작하지 않고도 UI를 업데이트 할 수 있게 됨 (재조정 과정을 통해 실제 DOM에 적용)

* 컴포넌트 모델

​	애플리케이션을 작은 조각으로 나누기를 권장 -> 재사용이 가능하며 유지보수가 용이함

* 불변 상태

  애플리케이션 상태를 불변하는 값의 집합으로 기술 -> UI가 특정 시점의 특정 상태를 반영하도록 보장함. 상태의 불변성 덕분에 Replay.io 처럼 시간 여행 디버깅을 지원하는 강력한 개발자 도구도 사용할 수 있음



### 리액트 출시

2013년 오픈소스로 공개 당시에는 JSX가 자바스크립트에 HTML을 넣어 관심사 분리 원칙을 해쳤다고 비난 받음. 그러나 점진적으로 웹에서 사용자 인터페이스를 구축하는 사실상 표준으로 자리 잡음.



### 플럭스 아키텍처

플럭스: 클라이언트 측 웹 어플리케이션 구축을 위한 아키텍처 디자인 패턴으로, 단방향 데이터 흐름을 강조하여 애플리케이션 데이터 흐름을 예측 가능하게 만듦.

> **액션**
>
> 새 데이터와 액션의 종류를 식별하는 속성을 포함하는 단순 객체
>
> **디스페처**
>
> 플럭스 아키텍서의 중심으로, 액션을 받아 등록된 스토어로 보냄
>
> **스토어**
>
> 애플리케이션의 상태와 로직을 포함함. 모델과 유사하지만 스토어는 다수 객체의 상태를 관리함
>
> **뷰**
>
> 리액트 컴포넌트로, 스토어에서 변경 이벤트를 받아 의존하는 데이터가 변경되면 스스로 업데이트함



### 플럭스 아키텍처의 장점

* 단일 정보 출처: 중앙 집중식 상태 관리
* 테스트 가능성
* 관심사 분리



## 1.4 그래서_ 리액트는 왜 필요한가요?

* 우리가 화면에 나타내고자 하는 바를 선언적으로 표현 가능해짐
* 대규모로 사용가능하도록 설계됨 (심지어 메타가)
* 오픈소스이며 무료로 사용 가능
* 활발한 생태계 
* 플랫폼에 구애받지 않음

